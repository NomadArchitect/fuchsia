# Copyright 2022 The Fuchsia Authors. All rights reserved.
# Use of this source code is governed by a BSD-style license that can be
# found in the LICENSE file.

import("//build/devicetree/dts_preprocess.gni")
import("//build/testing/golden_files.gni")

# Defines a devicetree source file that can be included by other devicetree files.
#
# Parameters
#   used_schemas (optional)
#     Array of driver schema targets that are used by this devicetree fragment.
#   sources (required)
#      Can only have one source file.
#   public_deps
#      Devicetree fragments referenced by this devicetree.
template("devicetree_fragment") {
  dts_preprocess(target_name) {
    forward_variables_from(invoker,
                           [
                             "used_schemas",
                             "sources",
                             "public_deps",
                           ])
    assert([ sources[0] ] == invoker.sources,
           "Devicetree fragment can only have one source file")
  }
}

# Defines a devicetree to be built into a devicetree blob.
#
# Parameters
#   deps (optional)
#     Array of |devicetree_fragment|s that this devicetree includes (via the /include/ statement).
#   used_schemas (optional)
#     Array of driver schema targets that are used by this devicetree fragment.
#   sources (required)
#     Single element array containing the devicetree source file.
#   golden (required)
#     Path to the golden devicetree source.
template("devicetree") {
  schema_sources_target = target_name + "_schema_files"
  schema_sources_filename = schema_sources_target + ".txt"

  all_schema_target = target_name + "_all_schema"
  all_schema_filename = all_schema_target + ".yaml"

  compiled_dtb_target = target_name + "_compiled_dtb"
  compiled_dtb_filename = target_name + ".dtb"

  processed_dts_target = target_name + "_raw_dts"

  decompiled_dtb_target = target_name + "_decompiled_dtb"
  decompiled_dtb_filename = decompiled_dtb_target + ".dts"

  golden_dts_target = target_name + "_golden_dts"

  validate_dtb_target = target_name + "_validate_dtb"
  validate_dtb_filename = validate_dtb_target + ".txt"

  if (defined(invoker.deps)) {
    devicetree_deps = invoker.deps
    has_includes = true
  } else {
    devicetree_deps = []
    has_includes = false
  }

  if (defined(invoker.used_schemas)) {
    used_schemas = invoker.used_schemas
  } else {
    used_schemas = []
  }

  # This generates a list of schemas used by the final devicetree.
  generated_file(schema_sources_target) {
    output_conversion = "list lines"
    outputs = [ "$target_gen_dir/$schema_sources_filename" ]

    data_keys = [ "devicetree_schema" ]
    walk_keys = [ "devicetree_drivers" ]
    deps = used_schemas + devicetree_deps + [ "//build/devicetree:core" ]
    rebase = root_build_dir
  }

  # This generates a schema that contains all of the schemas gathered by |schema_sources_target|.
  # This is a little bit magical, because the dt-mk-schema tool has to be provided all the schemas
  # at once. So we use the full list of schemas generated by |schema_sources_target| above, and the
  # run-dt-mk-schema.sh script generates a depfile so that ninja knows what schemas we used.
  action(all_schema_target) {
    deps = [ ":$schema_sources_target" ]

    script = "//build/devicetree/run-dt-mk-schema.sh"
    schema_output = get_target_outputs(":$schema_sources_target")
    depfile = "$target_out_dir/$all_schema_filename.d"
    args = [
      rebase_path("//third_party/dt-schema/vendor/bin/dt-mk-schema",
                  root_build_dir),
      rebase_path(depfile, root_build_dir),
      "@" + rebase_path(schema_output[0], root_build_dir),
      "-u",
      "-o",
      rebase_path("$target_out_dir/$all_schema_filename", root_build_dir),
    ]

    outputs = [ "$target_out_dir/$all_schema_filename" ]
  }

  if (has_includes) {
    dts_include_dirs_target = target_name + "_all_dts"
    dts_include_dirs_filename = dts_include_dirs_target + ".txt"

    # Each devicetree_fragment() call puts a devicetree in a directory tree that mimics the source tree,
    # so that we can properly restrict /include/ statements in DTC.
    # This generates a file containing paths to all of these directory trees, which we use below
    # when calling DTC.
    generated_file(dts_include_dirs_target) {
      deps = devicetree_deps

      data_keys = [ "devicetree_includes" ]
      outputs = [ "$target_gen_dir/$dts_include_dirs_filename" ]
      output_conversion = "list lines"
      rebase = root_build_dir
    }
  }

  # This passes the DTS file through the preprocessor to handle any C constants.
  dts_preprocess(processed_dts_target) {
    forward_variables_from(invoker,
                           [
                           # "used_schemas" is defined above.
                             "sources",
                             "deps",
                           ])

    assert([ sources[0] ] == invoker.sources,
           "devicetree can only have a single input file")
  }

  # This actually compiles the DTB.
  action(compiled_dtb_target) {
    deps = [ ":$processed_dts_target" ]
    script = "//build/devicetree/dtc.sh"

    dts_outputs = get_target_outputs(":$processed_dts_target")
    rebased_source = rebase_path(dts_outputs[0], root_build_dir)

    args = []
    if (has_includes) {
      deps += [ ":$dts_include_dirs_target" ]

      output_file = get_target_outputs(":$dts_include_dirs_target")
      args += [ rebase_path(output_file[0], root_build_dir) ]
    } else {
      args += [ "--" ]
    }

    args += [
      rebased_source,
      "-o",
      rebase_path("$target_out_dir/$compiled_dtb_filename", root_build_dir),
    ]

    outputs = [ "$target_out_dir/$compiled_dtb_filename" ]
  }

  # Decompile the compiled DTS so we can use it for the golden comparison.
  action(decompiled_dtb_target) {
    deps = [ ":$compiled_dtb_target" ]
    script = "//build/devicetree/dtc.sh"

    dtb_outputs = get_target_outputs(":$compiled_dtb_target")
    rebased_dtb = rebase_path(dtb_outputs[0], root_build_dir)

    outputs = [ "$target_out_dir/$decompiled_dtb_filename" ]

    args = [
      "--",
      "-I",
      "dtb",
      "-O",
      "dts",
      rebased_dtb,
      "-o",
      rebase_path("$target_out_dir/$decompiled_dtb_filename", root_build_dir),
    ]
  }

  # This is the actual golden file rule.
  golden_files(golden_dts_target) {
    deps = [ ":$decompiled_dtb_target" ]
    dtb_outputs = get_target_outputs(":$decompiled_dtb_target")
    comparisons = [
      {
        forward_variables_from(invoker, [ "golden" ])
        candidate = dtb_outputs[0]
      },
    ]
  }

  # This is the actual schema validation step. Note that we fail the validation if
  # any part of the devicetree does not match a schema (and the tool produces any output).
  # In the future we will probably want to make the tool exit if validation fails.
  action(validate_dtb_target) {
    deps = [
      ":$all_schema_target",
      ":$compiled_dtb_target",
    ]

    script = "//build/devicetree/run-dt-schema-tool.sh"
    schema_output = get_target_outputs(":$all_schema_target")
    dtb_output = get_target_outputs(":$compiled_dtb_target")
    my_output = "$target_out_dir/$validate_dtb_filename"

    outputs = [ my_output ]

    args = [
      rebase_path("//third_party/dt-schema/vendor/bin/dt-validate",
                  root_build_dir),
      rebase_path(my_output, root_build_dir),

      "-s",
      rebase_path(schema_output[0], root_build_dir),
      "-m",
      rebase_path(dtb_output[0], root_build_dir),
    ]
  }

  group(target_name) {
    deps = [
      ":$all_schema_target",
      ":$compiled_dtb_target",
      ":$golden_dts_target",
      ":$validate_dtb_target",
    ]
  }
}
