// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(unused_parens, unused_variables, unused_mut, unused_imports, unreachable_code)]

/// The type corresponding to the DriverOnlyService service.
#[derive(Debug)]
pub struct DriverOnlyService;

/// A helper trait for instances of the `DriverOnlyService` service.
pub trait DriverOnlyServiceInstance {
    /// The error type for the instance.
    type Error: ::core::error::Error + Send + Sync + 'static;

    /// The transport type created by connecting to a member.
    type Transport: ::fidl_next::protocol::Transport;

    /// Attempts to connect to the `member` member.
    fn member(
        &mut self,
    ) -> Result<
        ::fidl_next::bind::ClientEnd<
            Self::Transport,
            ::fidl_next::bind::ClientEnd<
                ::fidl_next::fuchsia::zx::Handle,
                crate::SomeDriverProtocol,
            >,
        >,
        Self::Error,
    >;
}

impl<___I> DriverOnlyServiceInstance for ::fidl_next::bind::ServiceInstance<___I, DriverOnlyService>
where
    ___I: ::fidl_next::protocol::ServiceInstance,
{
    type Error = ___I::Error;
    type Transport = ___I::Transport;

    fn member(
        &mut self,
    ) -> Result<
        ::fidl_next::bind::ClientEnd<
            Self::Transport,
            ::fidl_next::bind::ClientEnd<
                ::fidl_next::fuchsia::zx::Handle,
                crate::SomeDriverProtocol,
            >,
        >,
        Self::Error,
    > {
        self.as_untyped_mut().connect("member").map(::fidl_next::bind::ClientEnd::from_untyped)
    }
}

/// The type corresponding to the SomeDriverProtocol protocol.
#[derive(Debug)]
pub struct SomeDriverProtocol;

pub mod some_driver_protocol {}

/// A helper trait for the `SomeDriverProtocol` client sender.
pub trait SomeDriverProtocolClientSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> SomeDriverProtocolClientSender<___T>
    for ::fidl_next::bind::ClientSender<___T, SomeDriverProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A client handler for the SomeDriverProtocol protocol.
///
/// See [`SomeDriverProtocol`] for more details.
pub trait SomeDriverProtocolClientHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ClientProtocol<___T, ___H> for SomeDriverProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: SomeDriverProtocolClientHandler<___T>,
{
    fn on_event(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ClientSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}

/// A helper trait for the `SomeDriverProtocol` server sender.
pub trait SomeDriverProtocolServerSender<___T: ::fidl_next::protocol::Transport> {}

impl<___T> SomeDriverProtocolServerSender<___T>
    for ::fidl_next::bind::ServerSender<___T, SomeDriverProtocol>
where
    ___T: ::fidl_next::protocol::Transport,
{
}

/// A server handler for the SomeDriverProtocol protocol.
///
/// See [`SomeDriverProtocol`] for more details.
pub trait SomeDriverProtocolServerHandler<___T: ::fidl_next::protocol::Transport> {}

impl<___T, ___H> ::fidl_next::bind::ServerProtocol<___T, ___H> for SomeDriverProtocol
where
    ___T: ::fidl_next::protocol::Transport,
    ___H: SomeDriverProtocolServerHandler<___T>,
{
    fn on_one_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }

    fn on_two_way(
        handler: &mut ___H,
        sender: &::fidl_next::bind::ServerSender<___T, Self>,
        ordinal: u64,
        buffer: ___T::RecvBuffer,
        responder: ::fidl_next::protocol::Responder,
    ) {
        match ordinal {
            ordinal => {
                sender.close();
            }
        }
    }
}
