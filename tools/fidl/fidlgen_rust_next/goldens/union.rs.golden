// DO NOT EDIT: This file is machine-generated by fidlgen
#![warn(clippy::all)]
#![allow(
    unused_parens,
    unused_variables,
    unused_mut,
    unused_imports,
    unreachable_code,
    nonstandard_style
)]

#[derive(Clone, Debug)]
pub struct Empty {}

impl ::fidl::Encodable for Empty {
    type Encoded<'buf> = WireEmpty;
}

impl<___E> ::fidl::Encode<___E> for Empty {
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge! {
            let Self::Encoded {
            } = slot;
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<Empty> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireEmpty>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<Empty>
where
    ___E: ::fidl::Encoder + ?Sized,
    Empty: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        if let Some(inner) = this {
            ::fidl::EncoderExt::encode(encoder, inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl ::fidl::TakeFrom<WireEmpty> for Empty {
    fn take_from(from: &mut WireEmpty) -> Self {
        Self {}
    }
}

#[derive(Clone, Debug)]
#[repr(C)]
pub struct WireEmpty {}

unsafe impl<___D> ::fidl::Decode<___D> for WireEmpty
where
    ___D: ?Sized,
{
    fn decode(slot: ::fidl::Slot<'_, Self>, decoder: &mut ___D) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge! {
            let Self {
            } = slot;
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum EmptyFlexibleUnion {
    Unknown(u64),
}

impl ::fidl::Encodable for EmptyFlexibleUnion {
    type Encoded<'buf> = WireEmptyFlexibleUnion<'buf>;
}

impl<___E> ::fidl::Encode<___E> for EmptyFlexibleUnion
where
    ___E: ::fidl::Encoder + ?Sized,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireEmptyFlexibleUnion { raw } = slot);

        match self {
            Self::Unknown(ordinal) => {
                return Err(::fidl::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<EmptyFlexibleUnion> {
    type EncodedOption<'buf> = WireOptionalEmptyFlexibleUnion<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<EmptyFlexibleUnion>
where
    ___E: ::fidl::Encoder + ?Sized,
    EmptyFlexibleUnion: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalEmptyFlexibleUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireEmptyFlexibleUnion<'buf>> for EmptyFlexibleUnion {
    fn take_from(from: &mut WireEmptyFlexibleUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalEmptyFlexibleUnion<'buf>>
    for Option<Box<EmptyFlexibleUnion>>
{
    fn take_from(from: &mut WireOptionalEmptyFlexibleUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireEmptyFlexibleUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireEmptyFlexibleUnionRef {
    Unknown(u64),
}

pub enum WireEmptyFlexibleUnionMut {
    Unknown(u64),
}

impl WireEmptyFlexibleUnion<'_> {
    pub fn as_ref(&self) -> WireEmptyFlexibleUnionRef {
        match self.raw.ordinal() {
            unknown => WireEmptyFlexibleUnionRef::Unknown(unknown),
        }
    }

    pub fn as_mut(&mut self) -> WireEmptyFlexibleUnionMut {
        match self.raw.ordinal() {
            unknown => WireEmptyFlexibleUnionMut::Unknown(unknown),
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireEmptyFlexibleUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireEmptyFlexibleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalEmptyFlexibleUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalEmptyFlexibleUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireEmptyFlexibleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireEmptyFlexibleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireEmptyFlexibleUnion<'buf>> {
        if self.is_some() {
            Some(WireEmptyFlexibleUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalEmptyFlexibleUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalEmptyFlexibleUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalEmptyFlexibleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]

pub enum ExplicitFlexibleUnion {
    I(i64),
    F(f32),
    Unknown(u64),
}

impl ::fidl::Encodable for ExplicitFlexibleUnion {
    type Encoded<'buf> = WireExplicitFlexibleUnion<'buf>;
}

impl<___E> ::fidl::Encode<___E> for ExplicitFlexibleUnion
where
    ___E: ::fidl::Encoder + ?Sized,

    i64: ::fidl::Encode<___E>,
    f32: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireExplicitFlexibleUnion { raw } = slot);

        match self {
            Self::I(value) => ::fidl::RawWireUnion::encode_as::<___E, i64>(value, 1, encoder, raw)?,
            Self::F(value) => ::fidl::RawWireUnion::encode_as::<___E, f32>(value, 4, encoder, raw)?,

            Self::Unknown(ordinal) => {
                return Err(::fidl::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<ExplicitFlexibleUnion> {
    type EncodedOption<'buf> = WireOptionalExplicitFlexibleUnion<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<ExplicitFlexibleUnion>
where
    ___E: ::fidl::Encoder + ?Sized,
    ExplicitFlexibleUnion: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalExplicitFlexibleUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireExplicitFlexibleUnion<'buf>> for ExplicitFlexibleUnion {
    fn take_from(from: &mut WireExplicitFlexibleUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::I(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            4 => Self::F(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalExplicitFlexibleUnion<'buf>>
    for Option<Box<ExplicitFlexibleUnion>>
{
    fn take_from(from: &mut WireOptionalExplicitFlexibleUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireExplicitFlexibleUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireExplicitFlexibleUnionRef<'buf> {
    I(&'buf ::fidl::i64_le),
    F(&'buf ::fidl::f32_le),
    Unknown(u64),
}

pub enum WireExplicitFlexibleUnionMut<'buf> {
    I(&'buf mut ::fidl::i64_le),
    F(&'buf mut ::fidl::f32_le),
    Unknown(u64),
}

impl WireExplicitFlexibleUnion<'_> {
    pub fn as_ref(&self) -> WireExplicitFlexibleUnionRef<'_> {
        match self.raw.ordinal() {
            1 => WireExplicitFlexibleUnionRef::I(unsafe { self.raw.get().deref_unchecked() }),

            4 => WireExplicitFlexibleUnionRef::F(unsafe { self.raw.get().deref_unchecked() }),
            unknown => WireExplicitFlexibleUnionRef::Unknown(unknown),
        }
    }

    pub fn as_mut(&mut self) -> WireExplicitFlexibleUnionMut<'_> {
        match self.raw.ordinal() {
            1 => {
                WireExplicitFlexibleUnionMut::I(unsafe { self.raw.get_mut().deref_mut_unchecked() })
            }

            4 => {
                WireExplicitFlexibleUnionMut::F(unsafe { self.raw.get_mut().deref_mut_unchecked() })
            }
            unknown => WireExplicitFlexibleUnionMut::Unknown(unknown),
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireExplicitFlexibleUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i64_le: ::fidl::Decode<___D>,
    ::fidl::f32_le: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i64_le>(raw, decoder)?,
            4 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::f32_le>(raw, decoder)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireExplicitFlexibleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl::i64_le>().fmt(f) },
            4 => unsafe { self.raw.get().deref_unchecked::<::fidl::f32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitFlexibleUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalExplicitFlexibleUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitFlexibleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireExplicitFlexibleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireExplicitFlexibleUnion<'buf>> {
        if self.is_some() {
            Some(WireExplicitFlexibleUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalExplicitFlexibleUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalExplicitFlexibleUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i64_le: ::fidl::Decode<___D>,
    ::fidl::f32_le: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i64_le>(raw, decoder)?,
            4 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::f32_le>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalExplicitFlexibleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]

pub enum ExplicitFoo {
    I(i32),
    S(String),
    Unknown(u64),
}

impl ::fidl::Encodable for ExplicitFoo {
    type Encoded<'buf> = WireExplicitFoo<'buf>;
}

impl<___E> ::fidl::Encode<___E> for ExplicitFoo
where
    ___E: ::fidl::Encoder + ?Sized,

    i32: ::fidl::Encode<___E>,
    String: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireExplicitFoo { raw } = slot);

        match self {
            Self::I(value) => ::fidl::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?,
            Self::S(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }

            Self::Unknown(ordinal) => {
                return Err(::fidl::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<ExplicitFoo> {
    type EncodedOption<'buf> = WireOptionalExplicitFoo<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<ExplicitFoo>
where
    ___E: ::fidl::Encoder + ?Sized,
    ExplicitFoo: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalExplicitFoo { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireExplicitFoo<'buf>> for ExplicitFoo {
    fn take_from(from: &mut WireExplicitFoo<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::I(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::S(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalExplicitFoo<'buf>> for Option<Box<ExplicitFoo>> {
    fn take_from(from: &mut WireOptionalExplicitFoo<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireExplicitFoo<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireExplicitFooRef<'buf> {
    I(&'buf ::fidl::i32_le),
    S(&'buf ::fidl::WireString<'buf>),
    Unknown(u64),
}

pub enum WireExplicitFooMut<'buf> {
    I(&'buf mut ::fidl::i32_le),
    S(&'buf mut ::fidl::WireString<'buf>),
    Unknown(u64),
}

impl WireExplicitFoo<'_> {
    pub fn as_ref(&self) -> WireExplicitFooRef<'_> {
        match self.raw.ordinal() {
            1 => WireExplicitFooRef::I(unsafe { self.raw.get().deref_unchecked() }),

            2 => WireExplicitFooRef::S(unsafe { self.raw.get().deref_unchecked() }),
            unknown => WireExplicitFooRef::Unknown(unknown),
        }
    }

    pub fn as_mut(&mut self) -> WireExplicitFooMut<'_> {
        match self.raw.ordinal() {
            1 => WireExplicitFooMut::I(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            2 => WireExplicitFooMut::S(unsafe { self.raw.get_mut().deref_mut_unchecked() }),
            unknown => WireExplicitFooMut::Unknown(unknown),
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireExplicitFoo<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i32_le: ::fidl::Decode<___D>,
    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireExplicitFoo<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl::i32_le>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::WireString<'buf>>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitFoo<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalExplicitFoo<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitFoo<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireExplicitFoo<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireExplicitFoo<'buf>> {
        if self.is_some() {
            Some(WireExplicitFoo {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalExplicitFoo<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalExplicitFoo<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i32_le: ::fidl::Decode<___D>,
    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalExplicitFoo<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct Pizza {
    pub toppings: Vec<String>,
}

impl ::fidl::Encodable for Pizza {
    type Encoded<'buf> = WirePizza<'buf>;
}

impl<___E> ::fidl::Encode<___E> for Pizza
where
    Vec<String>: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge! {
            let Self::Encoded {
                toppings,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.toppings, encoder, toppings)?;
        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<Pizza> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WirePizza<'buf>>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<Pizza>
where
    ___E: ::fidl::Encoder + ?Sized,
    Pizza: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        if let Some(inner) = this {
            ::fidl::EncoderExt::encode(encoder, inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WirePizza<'buf>> for Pizza {
    fn take_from(from: &mut WirePizza<'buf>) -> Self {
        Self { toppings: ::fidl::TakeFrom::take_from(&mut from.toppings) }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WirePizza<'buf> {
    pub toppings: ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>,
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WirePizza<'buf>
where
    ___D: ?Sized,

    ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>: ::fidl::Decode<___D>,
{
    fn decode(slot: ::fidl::Slot<'_, Self>, decoder: &mut ___D) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge! {
            let Self {
                mut toppings,
            } = slot;
        }
        ::fidl::Decode::decode(toppings.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct Pasta {
    pub sauce: String,
}

impl ::fidl::Encodable for Pasta {
    type Encoded<'buf> = WirePasta<'buf>;
}

impl<___E> ::fidl::Encode<___E> for Pasta
where
    String: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge! {
            let Self::Encoded {
                sauce,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.sauce, encoder, sauce)?;
        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<Pasta> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WirePasta<'buf>>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<Pasta>
where
    ___E: ::fidl::Encoder + ?Sized,
    Pasta: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        if let Some(inner) = this {
            ::fidl::EncoderExt::encode(encoder, inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WirePasta<'buf>> for Pasta {
    fn take_from(from: &mut WirePasta<'buf>) -> Self {
        Self { sauce: ::fidl::TakeFrom::take_from(&mut from.sauce) }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WirePasta<'buf> {
    pub sauce: ::fidl::WireString<'buf>,
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WirePasta<'buf>
where
    ___D: ?Sized,

    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
{
    fn decode(slot: ::fidl::Slot<'_, Self>, decoder: &mut ___D) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge! {
            let Self {
                mut sauce,
            } = slot;
        }
        ::fidl::Decode::decode(sauce.as_mut(), decoder)?;
        let sauce = unsafe { sauce.deref_unchecked() };

        if sauce.len() > 16 {
            return Err(::fidl::DecodeError::VectorTooLong { size: sauce.len() as u64, limit: 16 });
        }

        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum ExplicitPizzaOrPasta {
    Pizza(crate::Pizza),
    Pasta(crate::Pasta),
}

impl ::fidl::Encodable for ExplicitPizzaOrPasta {
    type Encoded<'buf> = WireExplicitPizzaOrPasta<'buf>;
}

impl<___E> ::fidl::Encode<___E> for ExplicitPizzaOrPasta
where
    ___E: ::fidl::Encoder + ?Sized,

    crate::Pizza: ::fidl::Encode<___E>,
    crate::Pasta: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireExplicitPizzaOrPasta { raw } = slot);

        match self {
            Self::Pizza(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, crate::Pizza>(value, 1, encoder, raw)?
            }
            Self::Pasta(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, crate::Pasta>(value, 4, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<ExplicitPizzaOrPasta> {
    type EncodedOption<'buf> = WireOptionalExplicitPizzaOrPasta<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<ExplicitPizzaOrPasta>
where
    ___E: ::fidl::Encoder + ?Sized,
    ExplicitPizzaOrPasta: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalExplicitPizzaOrPasta { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireExplicitPizzaOrPasta<'buf>> for ExplicitPizzaOrPasta {
    fn take_from(from: &mut WireExplicitPizzaOrPasta<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Pizza(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            4 => Self::Pasta(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalExplicitPizzaOrPasta<'buf>>
    for Option<Box<ExplicitPizzaOrPasta>>
{
    fn take_from(from: &mut WireOptionalExplicitPizzaOrPasta<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireExplicitPizzaOrPasta<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireExplicitPizzaOrPastaRef<'buf> {
    Pizza(&'buf crate::WirePizza<'buf>),
    Pasta(&'buf crate::WirePasta<'buf>),
}

pub enum WireExplicitPizzaOrPastaMut<'buf> {
    Pizza(&'buf mut crate::WirePizza<'buf>),
    Pasta(&'buf mut crate::WirePasta<'buf>),
}

impl WireExplicitPizzaOrPasta<'_> {
    pub fn as_ref(&self) -> WireExplicitPizzaOrPastaRef<'_> {
        match self.raw.ordinal() {
            1 => WireExplicitPizzaOrPastaRef::Pizza(unsafe { self.raw.get().deref_unchecked() }),

            4 => WireExplicitPizzaOrPastaRef::Pasta(unsafe { self.raw.get().deref_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireExplicitPizzaOrPastaMut<'_> {
        match self.raw.ordinal() {
            1 => WireExplicitPizzaOrPastaMut::Pizza(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            4 => WireExplicitPizzaOrPastaMut::Pasta(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireExplicitPizzaOrPasta<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    crate::WirePizza<'buf>: ::fidl::Decode<___D>,
    crate::WirePasta<'buf>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, crate::WirePizza<'buf>>(raw, decoder)?,
            4 => ::fidl::RawWireUnion::decode_as::<___D, crate::WirePasta<'buf>>(raw, decoder)?,

            ord => return Err(fidl::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireExplicitPizzaOrPasta<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WirePizza<'buf>>().fmt(f) },
            4 => unsafe { self.raw.get().deref_unchecked::<crate::WirePasta<'buf>>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitPizzaOrPasta<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalExplicitPizzaOrPasta<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitPizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireExplicitPizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireExplicitPizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(WireExplicitPizzaOrPasta {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalExplicitPizzaOrPasta<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalExplicitPizzaOrPasta<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    crate::WirePizza<'buf>: ::fidl::Decode<___D>,
    crate::WirePasta<'buf>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, crate::WirePizza<'buf>>(raw, decoder)?,
            4 => ::fidl::RawWireUnion::decode_as::<___D, crate::WirePasta<'buf>>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalExplicitPizzaOrPasta<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]

pub enum ExplicitStrictFoo {
    I(i32),
    S(String),
}

impl ::fidl::Encodable for ExplicitStrictFoo {
    type Encoded<'buf> = WireExplicitStrictFoo<'buf>;
}

impl<___E> ::fidl::Encode<___E> for ExplicitStrictFoo
where
    ___E: ::fidl::Encoder + ?Sized,

    i32: ::fidl::Encode<___E>,
    String: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireExplicitStrictFoo { raw } = slot);

        match self {
            Self::I(value) => ::fidl::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?,
            Self::S(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, String>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<ExplicitStrictFoo> {
    type EncodedOption<'buf> = WireOptionalExplicitStrictFoo<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<ExplicitStrictFoo>
where
    ___E: ::fidl::Encoder + ?Sized,
    ExplicitStrictFoo: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalExplicitStrictFoo { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireExplicitStrictFoo<'buf>> for ExplicitStrictFoo {
    fn take_from(from: &mut WireExplicitStrictFoo<'buf>) -> Self {
        match from.raw.ordinal() {
            2 => Self::I(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::S(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalExplicitStrictFoo<'buf>>
    for Option<Box<ExplicitStrictFoo>>
{
    fn take_from(from: &mut WireOptionalExplicitStrictFoo<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireExplicitStrictFoo<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireExplicitStrictFooRef<'buf> {
    I(&'buf ::fidl::i32_le),
    S(&'buf ::fidl::WireString<'buf>),
}

pub enum WireExplicitStrictFooMut<'buf> {
    I(&'buf mut ::fidl::i32_le),
    S(&'buf mut ::fidl::WireString<'buf>),
}

impl WireExplicitStrictFoo<'_> {
    pub fn as_ref(&self) -> WireExplicitStrictFooRef<'_> {
        match self.raw.ordinal() {
            2 => WireExplicitStrictFooRef::I(unsafe { self.raw.get().deref_unchecked() }),

            3 => WireExplicitStrictFooRef::S(unsafe { self.raw.get().deref_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireExplicitStrictFooMut<'_> {
        match self.raw.ordinal() {
            2 => WireExplicitStrictFooMut::I(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            3 => WireExplicitStrictFooMut::S(unsafe { self.raw.get_mut().deref_mut_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireExplicitStrictFoo<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i32_le: ::fidl::Decode<___D>,
    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,
            3 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,

            ord => return Err(fidl::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireExplicitStrictFoo<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::i32_le>().fmt(f) },
            3 => unsafe { self.raw.get().deref_unchecked::<::fidl::WireString<'buf>>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitStrictFoo<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalExplicitStrictFoo<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitStrictFoo<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireExplicitStrictFoo<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireExplicitStrictFoo<'buf>> {
        if self.is_some() {
            Some(WireExplicitStrictFoo {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalExplicitStrictFoo<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalExplicitStrictFoo<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i32_le: ::fidl::Decode<___D>,
    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,
            3 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalExplicitStrictFoo<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]

pub enum ExplicitUnion {
    Primitive(i32),
    Stringneedsconstructor(String),
}

impl ::fidl::Encodable for ExplicitUnion {
    type Encoded<'buf> = WireExplicitUnion<'buf>;
}

impl<___E> ::fidl::Encode<___E> for ExplicitUnion
where
    ___E: ::fidl::Encoder + ?Sized,

    i32: ::fidl::Encode<___E>,
    String: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireExplicitUnion { raw } = slot);

        match self {
            Self::Primitive(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }
            Self::Stringneedsconstructor(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, String>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<ExplicitUnion> {
    type EncodedOption<'buf> = WireOptionalExplicitUnion<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<ExplicitUnion>
where
    ___E: ::fidl::Encoder + ?Sized,
    ExplicitUnion: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalExplicitUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireExplicitUnion<'buf>> for ExplicitUnion {
    fn take_from(from: &mut WireExplicitUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Primitive(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::Stringneedsconstructor(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalExplicitUnion<'buf>> for Option<Box<ExplicitUnion>> {
    fn take_from(from: &mut WireOptionalExplicitUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireExplicitUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireExplicitUnionRef<'buf> {
    Primitive(&'buf ::fidl::i32_le),
    Stringneedsconstructor(&'buf ::fidl::WireString<'buf>),
}

pub enum WireExplicitUnionMut<'buf> {
    Primitive(&'buf mut ::fidl::i32_le),
    Stringneedsconstructor(&'buf mut ::fidl::WireString<'buf>),
}

impl WireExplicitUnion<'_> {
    pub fn as_ref(&self) -> WireExplicitUnionRef<'_> {
        match self.raw.ordinal() {
            1 => WireExplicitUnionRef::Primitive(unsafe { self.raw.get().deref_unchecked() }),

            3 => WireExplicitUnionRef::Stringneedsconstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireExplicitUnionMut<'_> {
        match self.raw.ordinal() {
            1 => {
                WireExplicitUnionMut::Primitive(unsafe { self.raw.get_mut().deref_mut_unchecked() })
            }

            3 => WireExplicitUnionMut::Stringneedsconstructor(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireExplicitUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i32_le: ::fidl::Decode<___D>,
    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,
            3 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,

            ord => return Err(fidl::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireExplicitUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl::i32_le>().fmt(f) },
            3 => unsafe { self.raw.get().deref_unchecked::<::fidl::WireString<'buf>>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalExplicitUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalExplicitUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireExplicitUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireExplicitUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireExplicitUnion<'buf>> {
        if self.is_some() {
            Some(WireExplicitUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalExplicitUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalExplicitUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i32_le: ::fidl::Decode<___D>,
    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,
            3 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalExplicitUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]

pub enum FieldCollision {
    FieldCollisionTag(i32),
}

impl ::fidl::Encodable for FieldCollision {
    type Encoded<'buf> = WireFieldCollision<'buf>;
}

impl<___E> ::fidl::Encode<___E> for FieldCollision
where
    ___E: ::fidl::Encoder + ?Sized,

    i32: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireFieldCollision { raw } = slot);

        match self {
            Self::FieldCollisionTag(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<FieldCollision> {
    type EncodedOption<'buf> = WireOptionalFieldCollision<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<FieldCollision>
where
    ___E: ::fidl::Encoder + ?Sized,
    FieldCollision: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalFieldCollision { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireFieldCollision<'buf>> for FieldCollision {
    fn take_from(from: &mut WireFieldCollision<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::FieldCollisionTag(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalFieldCollision<'buf>> for Option<Box<FieldCollision>> {
    fn take_from(from: &mut WireOptionalFieldCollision<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireFieldCollision<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireFieldCollisionRef<'buf> {
    FieldCollisionTag(&'buf ::fidl::i32_le),
}

pub enum WireFieldCollisionMut<'buf> {
    FieldCollisionTag(&'buf mut ::fidl::i32_le),
}

impl WireFieldCollision<'_> {
    pub fn as_ref(&self) -> WireFieldCollisionRef<'_> {
        match self.raw.ordinal() {
            1 => WireFieldCollisionRef::FieldCollisionTag(unsafe {
                self.raw.get().deref_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireFieldCollisionMut<'_> {
        match self.raw.ordinal() {
            1 => WireFieldCollisionMut::FieldCollisionTag(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireFieldCollision<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i32_le: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,

            ord => return Err(fidl::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireFieldCollision<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl::i32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalFieldCollision<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalFieldCollision<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireFieldCollision<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireFieldCollision<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireFieldCollision<'buf>> {
        if self.is_some() {
            Some(WireFieldCollision {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalFieldCollision<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalFieldCollision<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i32_le: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalFieldCollision<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]

pub enum FlexibleFoo {
    S(String),
    I(i32),
    Unknown(u64),
}

impl ::fidl::Encodable for FlexibleFoo {
    type Encoded<'buf> = WireFlexibleFoo<'buf>;
}

impl<___E> ::fidl::Encode<___E> for FlexibleFoo
where
    ___E: ::fidl::Encoder + ?Sized,

    String: ::fidl::Encode<___E>,
    i32: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireFlexibleFoo { raw } = slot);

        match self {
            Self::S(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, String>(value, 1, encoder, raw)?
            }
            Self::I(value) => ::fidl::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?,

            Self::Unknown(ordinal) => {
                return Err(::fidl::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<FlexibleFoo> {
    type EncodedOption<'buf> = WireOptionalFlexibleFoo<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<FlexibleFoo>
where
    ___E: ::fidl::Encoder + ?Sized,
    FlexibleFoo: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalFlexibleFoo { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireFlexibleFoo<'buf>> for FlexibleFoo {
    fn take_from(from: &mut WireFlexibleFoo<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::S(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::I(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalFlexibleFoo<'buf>> for Option<Box<FlexibleFoo>> {
    fn take_from(from: &mut WireOptionalFlexibleFoo<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireFlexibleFoo<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireFlexibleFooRef<'buf> {
    S(&'buf ::fidl::WireString<'buf>),
    I(&'buf ::fidl::i32_le),
    Unknown(u64),
}

pub enum WireFlexibleFooMut<'buf> {
    S(&'buf mut ::fidl::WireString<'buf>),
    I(&'buf mut ::fidl::i32_le),
    Unknown(u64),
}

impl WireFlexibleFoo<'_> {
    pub fn as_ref(&self) -> WireFlexibleFooRef<'_> {
        match self.raw.ordinal() {
            1 => WireFlexibleFooRef::S(unsafe { self.raw.get().deref_unchecked() }),

            2 => WireFlexibleFooRef::I(unsafe { self.raw.get().deref_unchecked() }),
            unknown => WireFlexibleFooRef::Unknown(unknown),
        }
    }

    pub fn as_mut(&mut self) -> WireFlexibleFooMut<'_> {
        match self.raw.ordinal() {
            1 => WireFlexibleFooMut::S(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            2 => WireFlexibleFooMut::I(unsafe { self.raw.get_mut().deref_mut_unchecked() }),
            unknown => WireFlexibleFooMut::Unknown(unknown),
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireFlexibleFoo<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
    ::fidl::i32_le: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireFlexibleFoo<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl::WireString<'buf>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::i32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalFlexibleFoo<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalFlexibleFoo<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireFlexibleFoo<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireFlexibleFoo<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireFlexibleFoo<'buf>> {
        if self.is_some() {
            Some(WireFlexibleFoo {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalFlexibleFoo<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalFlexibleFoo<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
    ::fidl::i32_le: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalFlexibleFoo<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]

pub enum FlexiblePizzaOrPasta {
    Pizza(crate::Pizza),
    Pasta(crate::Pasta),
    Unknown(u64),
}

impl ::fidl::Encodable for FlexiblePizzaOrPasta {
    type Encoded<'buf> = WireFlexiblePizzaOrPasta<'buf>;
}

impl<___E> ::fidl::Encode<___E> for FlexiblePizzaOrPasta
where
    ___E: ::fidl::Encoder + ?Sized,

    crate::Pizza: ::fidl::Encode<___E>,
    crate::Pasta: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireFlexiblePizzaOrPasta { raw } = slot);

        match self {
            Self::Pizza(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, crate::Pizza>(value, 1, encoder, raw)?
            }
            Self::Pasta(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, crate::Pasta>(value, 2, encoder, raw)?
            }

            Self::Unknown(ordinal) => {
                return Err(::fidl::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<FlexiblePizzaOrPasta> {
    type EncodedOption<'buf> = WireOptionalFlexiblePizzaOrPasta<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<FlexiblePizzaOrPasta>
where
    ___E: ::fidl::Encoder + ?Sized,
    FlexiblePizzaOrPasta: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalFlexiblePizzaOrPasta { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireFlexiblePizzaOrPasta<'buf>> for FlexiblePizzaOrPasta {
    fn take_from(from: &mut WireFlexiblePizzaOrPasta<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Pizza(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Pasta(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalFlexiblePizzaOrPasta<'buf>>
    for Option<Box<FlexiblePizzaOrPasta>>
{
    fn take_from(from: &mut WireOptionalFlexiblePizzaOrPasta<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireFlexiblePizzaOrPasta<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireFlexiblePizzaOrPastaRef<'buf> {
    Pizza(&'buf crate::WirePizza<'buf>),
    Pasta(&'buf crate::WirePasta<'buf>),
    Unknown(u64),
}

pub enum WireFlexiblePizzaOrPastaMut<'buf> {
    Pizza(&'buf mut crate::WirePizza<'buf>),
    Pasta(&'buf mut crate::WirePasta<'buf>),
    Unknown(u64),
}

impl WireFlexiblePizzaOrPasta<'_> {
    pub fn as_ref(&self) -> WireFlexiblePizzaOrPastaRef<'_> {
        match self.raw.ordinal() {
            1 => WireFlexiblePizzaOrPastaRef::Pizza(unsafe { self.raw.get().deref_unchecked() }),

            2 => WireFlexiblePizzaOrPastaRef::Pasta(unsafe { self.raw.get().deref_unchecked() }),
            unknown => WireFlexiblePizzaOrPastaRef::Unknown(unknown),
        }
    }

    pub fn as_mut(&mut self) -> WireFlexiblePizzaOrPastaMut<'_> {
        match self.raw.ordinal() {
            1 => WireFlexiblePizzaOrPastaMut::Pizza(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => WireFlexiblePizzaOrPastaMut::Pasta(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            unknown => WireFlexiblePizzaOrPastaMut::Unknown(unknown),
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireFlexiblePizzaOrPasta<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    crate::WirePizza<'buf>: ::fidl::Decode<___D>,
    crate::WirePasta<'buf>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, crate::WirePizza<'buf>>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, crate::WirePasta<'buf>>(raw, decoder)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireFlexiblePizzaOrPasta<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WirePizza<'buf>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<crate::WirePasta<'buf>>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalFlexiblePizzaOrPasta<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalFlexiblePizzaOrPasta<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireFlexiblePizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireFlexiblePizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireFlexiblePizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(WireFlexiblePizzaOrPasta {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalFlexiblePizzaOrPasta<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalFlexiblePizzaOrPasta<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    crate::WirePizza<'buf>: ::fidl::Decode<___D>,
    crate::WirePasta<'buf>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, crate::WirePizza<'buf>>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, crate::WirePasta<'buf>>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalFlexiblePizzaOrPasta<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]

pub enum FlexibleUnion {
    Primitive(i32),
    Stringneedsconstructor(String),
    Vectorstringalsoneedsconstructor(Vec<String>),
    Unknown(u64),
}

impl ::fidl::Encodable for FlexibleUnion {
    type Encoded<'buf> = WireFlexibleUnion<'buf>;
}

impl<___E> ::fidl::Encode<___E> for FlexibleUnion
where
    ___E: ::fidl::Encoder + ?Sized,

    i32: ::fidl::Encode<___E>,
    String: ::fidl::Encode<___E>,
    Vec<String>: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireFlexibleUnion { raw } = slot);

        match self {
            Self::Primitive(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }
            Self::Stringneedsconstructor(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }
            Self::Vectorstringalsoneedsconstructor(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, Vec<String>>(value, 3, encoder, raw)?
            }

            Self::Unknown(ordinal) => {
                return Err(::fidl::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<FlexibleUnion> {
    type EncodedOption<'buf> = WireOptionalFlexibleUnion<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<FlexibleUnion>
where
    ___E: ::fidl::Encoder + ?Sized,
    FlexibleUnion: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalFlexibleUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireFlexibleUnion<'buf>> for FlexibleUnion {
    fn take_from(from: &mut WireFlexibleUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Primitive(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Stringneedsconstructor(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::Vectorstringalsoneedsconstructor(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalFlexibleUnion<'buf>> for Option<Box<FlexibleUnion>> {
    fn take_from(from: &mut WireOptionalFlexibleUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireFlexibleUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireFlexibleUnionRef<'buf> {
    Primitive(&'buf ::fidl::i32_le),
    Stringneedsconstructor(&'buf ::fidl::WireString<'buf>),
    Vectorstringalsoneedsconstructor(&'buf ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>),
    Unknown(u64),
}

pub enum WireFlexibleUnionMut<'buf> {
    Primitive(&'buf mut ::fidl::i32_le),
    Stringneedsconstructor(&'buf mut ::fidl::WireString<'buf>),
    Vectorstringalsoneedsconstructor(&'buf mut ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>),
    Unknown(u64),
}

impl WireFlexibleUnion<'_> {
    pub fn as_ref(&self) -> WireFlexibleUnionRef<'_> {
        match self.raw.ordinal() {
            1 => WireFlexibleUnionRef::Primitive(unsafe { self.raw.get().deref_unchecked() }),

            2 => WireFlexibleUnionRef::Stringneedsconstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),

            3 => WireFlexibleUnionRef::Vectorstringalsoneedsconstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),
            unknown => WireFlexibleUnionRef::Unknown(unknown),
        }
    }

    pub fn as_mut(&mut self) -> WireFlexibleUnionMut<'_> {
        match self.raw.ordinal() {
            1 => {
                WireFlexibleUnionMut::Primitive(unsafe { self.raw.get_mut().deref_mut_unchecked() })
            }

            2 => WireFlexibleUnionMut::Stringneedsconstructor(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            3 => WireFlexibleUnionMut::Vectorstringalsoneedsconstructor(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            unknown => WireFlexibleUnionMut::Unknown(unknown),
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireFlexibleUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i32_le: ::fidl::Decode<___D>,
    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
    ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,
            3 => ::fidl::RawWireUnion::decode_as::<
                ___D,
                ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>,
            >(raw, decoder)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireFlexibleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl::i32_le>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::WireString<'buf>>().fmt(f) },
            3 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<::fidl::WireVector<'buf, ::fidl::WireString<'buf>>>()
                    .fmt(f)
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalFlexibleUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalFlexibleUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireFlexibleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireFlexibleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireFlexibleUnion<'buf>> {
        if self.is_some() {
            Some(WireFlexibleUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalFlexibleUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalFlexibleUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i32_le: ::fidl::Decode<___D>,
    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
    ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,
            3 => ::fidl::RawWireUnion::decode_as::<
                ___D,
                ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>,
            >(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalFlexibleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]

pub enum NewerSimpleUnion {
    I(i64),
    S(String),
    V(Vec<String>),
    Unknown(u64),
}

impl ::fidl::Encodable for NewerSimpleUnion {
    type Encoded<'buf> = WireNewerSimpleUnion<'buf>;
}

impl<___E> ::fidl::Encode<___E> for NewerSimpleUnion
where
    ___E: ::fidl::Encoder + ?Sized,

    i64: ::fidl::Encode<___E>,
    String: ::fidl::Encode<___E>,
    Vec<String>: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireNewerSimpleUnion { raw } = slot);

        match self {
            Self::I(value) => ::fidl::RawWireUnion::encode_as::<___E, i64>(value, 1, encoder, raw)?,
            Self::S(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }
            Self::V(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, Vec<String>>(value, 3, encoder, raw)?
            }

            Self::Unknown(ordinal) => {
                return Err(::fidl::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<NewerSimpleUnion> {
    type EncodedOption<'buf> = WireOptionalNewerSimpleUnion<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<NewerSimpleUnion>
where
    ___E: ::fidl::Encoder + ?Sized,
    NewerSimpleUnion: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalNewerSimpleUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireNewerSimpleUnion<'buf>> for NewerSimpleUnion {
    fn take_from(from: &mut WireNewerSimpleUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::I(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::S(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::V(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalNewerSimpleUnion<'buf>> for Option<Box<NewerSimpleUnion>> {
    fn take_from(from: &mut WireOptionalNewerSimpleUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireNewerSimpleUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireNewerSimpleUnionRef<'buf> {
    I(&'buf ::fidl::i64_le),
    S(&'buf ::fidl::WireString<'buf>),
    V(&'buf ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>),
    Unknown(u64),
}

pub enum WireNewerSimpleUnionMut<'buf> {
    I(&'buf mut ::fidl::i64_le),
    S(&'buf mut ::fidl::WireString<'buf>),
    V(&'buf mut ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>),
    Unknown(u64),
}

impl WireNewerSimpleUnion<'_> {
    pub fn as_ref(&self) -> WireNewerSimpleUnionRef<'_> {
        match self.raw.ordinal() {
            1 => WireNewerSimpleUnionRef::I(unsafe { self.raw.get().deref_unchecked() }),

            2 => WireNewerSimpleUnionRef::S(unsafe { self.raw.get().deref_unchecked() }),

            3 => WireNewerSimpleUnionRef::V(unsafe { self.raw.get().deref_unchecked() }),
            unknown => WireNewerSimpleUnionRef::Unknown(unknown),
        }
    }

    pub fn as_mut(&mut self) -> WireNewerSimpleUnionMut<'_> {
        match self.raw.ordinal() {
            1 => WireNewerSimpleUnionMut::I(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            2 => WireNewerSimpleUnionMut::S(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            3 => WireNewerSimpleUnionMut::V(unsafe { self.raw.get_mut().deref_mut_unchecked() }),
            unknown => WireNewerSimpleUnionMut::Unknown(unknown),
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireNewerSimpleUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i64_le: ::fidl::Decode<___D>,
    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
    ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i64_le>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,
            3 => ::fidl::RawWireUnion::decode_as::<
                ___D,
                ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>,
            >(raw, decoder)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireNewerSimpleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl::i64_le>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::WireString<'buf>>().fmt(f) },
            3 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<::fidl::WireVector<'buf, ::fidl::WireString<'buf>>>()
                    .fmt(f)
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalNewerSimpleUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalNewerSimpleUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireNewerSimpleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireNewerSimpleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireNewerSimpleUnion<'buf>> {
        if self.is_some() {
            Some(WireNewerSimpleUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalNewerSimpleUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalNewerSimpleUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i64_le: ::fidl::Decode<___D>,
    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
    ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i64_le>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,
            3 => ::fidl::RawWireUnion::decode_as::<
                ___D,
                ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>,
            >(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalNewerSimpleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct NullableUnionStruct {
    pub the_union: Option<Box<crate::Union>>,
}

impl ::fidl::Encodable for NullableUnionStruct {
    type Encoded<'buf> = WireNullableUnionStruct<'buf>;
}

impl<___E> ::fidl::Encode<___E> for NullableUnionStruct
where
    Option<Box<crate::Union>>: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge! {
            let Self::Encoded {
                the_union,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.the_union, encoder, the_union)?;
        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<NullableUnionStruct> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireNullableUnionStruct<'buf>>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<NullableUnionStruct>
where
    ___E: ::fidl::Encoder + ?Sized,
    NullableUnionStruct: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        if let Some(inner) = this {
            ::fidl::EncoderExt::encode(encoder, inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireNullableUnionStruct<'buf>> for NullableUnionStruct {
    fn take_from(from: &mut WireNullableUnionStruct<'buf>) -> Self {
        Self { the_union: ::fidl::TakeFrom::take_from(&mut from.the_union) }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireNullableUnionStruct<'buf> {
    pub the_union: crate::WireOptionalUnion<'buf>,
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireNullableUnionStruct<'buf>
where
    ___D: ?Sized,

    crate::WireOptionalUnion<'buf>: ::fidl::Decode<___D>,
{
    fn decode(slot: ::fidl::Slot<'_, Self>, decoder: &mut ___D) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge! {
            let Self {
                mut the_union,
            } = slot;
        }
        ::fidl::Decode::decode(the_union.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum OlderSimpleUnion {
    I(i64),
    F(f32),
    Unknown(u64),
}

impl ::fidl::Encodable for OlderSimpleUnion {
    type Encoded<'buf> = WireOlderSimpleUnion<'buf>;
}

impl<___E> ::fidl::Encode<___E> for OlderSimpleUnion
where
    ___E: ::fidl::Encoder + ?Sized,

    i64: ::fidl::Encode<___E>,
    f32: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOlderSimpleUnion { raw } = slot);

        match self {
            Self::I(value) => ::fidl::RawWireUnion::encode_as::<___E, i64>(value, 1, encoder, raw)?,
            Self::F(value) => ::fidl::RawWireUnion::encode_as::<___E, f32>(value, 2, encoder, raw)?,

            Self::Unknown(ordinal) => {
                return Err(::fidl::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<OlderSimpleUnion> {
    type EncodedOption<'buf> = WireOptionalOlderSimpleUnion<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<OlderSimpleUnion>
where
    ___E: ::fidl::Encoder + ?Sized,
    OlderSimpleUnion: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalOlderSimpleUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireOlderSimpleUnion<'buf>> for OlderSimpleUnion {
    fn take_from(from: &mut WireOlderSimpleUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::I(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::F(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalOlderSimpleUnion<'buf>> for Option<Box<OlderSimpleUnion>> {
    fn take_from(from: &mut WireOptionalOlderSimpleUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireOlderSimpleUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireOlderSimpleUnionRef<'buf> {
    I(&'buf ::fidl::i64_le),
    F(&'buf ::fidl::f32_le),
    Unknown(u64),
}

pub enum WireOlderSimpleUnionMut<'buf> {
    I(&'buf mut ::fidl::i64_le),
    F(&'buf mut ::fidl::f32_le),
    Unknown(u64),
}

impl WireOlderSimpleUnion<'_> {
    pub fn as_ref(&self) -> WireOlderSimpleUnionRef<'_> {
        match self.raw.ordinal() {
            1 => WireOlderSimpleUnionRef::I(unsafe { self.raw.get().deref_unchecked() }),

            2 => WireOlderSimpleUnionRef::F(unsafe { self.raw.get().deref_unchecked() }),
            unknown => WireOlderSimpleUnionRef::Unknown(unknown),
        }
    }

    pub fn as_mut(&mut self) -> WireOlderSimpleUnionMut<'_> {
        match self.raw.ordinal() {
            1 => WireOlderSimpleUnionMut::I(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            2 => WireOlderSimpleUnionMut::F(unsafe { self.raw.get_mut().deref_mut_unchecked() }),
            unknown => WireOlderSimpleUnionMut::Unknown(unknown),
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOlderSimpleUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i64_le: ::fidl::Decode<___D>,
    ::fidl::f32_le: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i64_le>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::f32_le>(raw, decoder)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOlderSimpleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl::i64_le>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::f32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalOlderSimpleUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalOlderSimpleUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireOlderSimpleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireOlderSimpleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireOlderSimpleUnion<'buf>> {
        if self.is_some() {
            Some(WireOlderSimpleUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalOlderSimpleUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalOlderSimpleUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i64_le: ::fidl::Decode<___D>,
    ::fidl::f32_le: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i64_le>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::f32_le>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalOlderSimpleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]

pub enum PizzaOrPasta {
    Pizza(crate::Pizza),
    Pasta(crate::Pasta),
}

impl ::fidl::Encodable for PizzaOrPasta {
    type Encoded<'buf> = WirePizzaOrPasta<'buf>;
}

impl<___E> ::fidl::Encode<___E> for PizzaOrPasta
where
    ___E: ::fidl::Encoder + ?Sized,

    crate::Pizza: ::fidl::Encode<___E>,
    crate::Pasta: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WirePizzaOrPasta { raw } = slot);

        match self {
            Self::Pizza(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, crate::Pizza>(value, 1, encoder, raw)?
            }
            Self::Pasta(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, crate::Pasta>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<PizzaOrPasta> {
    type EncodedOption<'buf> = WireOptionalPizzaOrPasta<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<PizzaOrPasta>
where
    ___E: ::fidl::Encoder + ?Sized,
    PizzaOrPasta: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalPizzaOrPasta { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WirePizzaOrPasta<'buf>> for PizzaOrPasta {
    fn take_from(from: &mut WirePizzaOrPasta<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Pizza(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Pasta(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalPizzaOrPasta<'buf>> for Option<Box<PizzaOrPasta>> {
    fn take_from(from: &mut WireOptionalPizzaOrPasta<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WirePizzaOrPasta<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WirePizzaOrPastaRef<'buf> {
    Pizza(&'buf crate::WirePizza<'buf>),
    Pasta(&'buf crate::WirePasta<'buf>),
}

pub enum WirePizzaOrPastaMut<'buf> {
    Pizza(&'buf mut crate::WirePizza<'buf>),
    Pasta(&'buf mut crate::WirePasta<'buf>),
}

impl WirePizzaOrPasta<'_> {
    pub fn as_ref(&self) -> WirePizzaOrPastaRef<'_> {
        match self.raw.ordinal() {
            1 => WirePizzaOrPastaRef::Pizza(unsafe { self.raw.get().deref_unchecked() }),

            2 => WirePizzaOrPastaRef::Pasta(unsafe { self.raw.get().deref_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WirePizzaOrPastaMut<'_> {
        match self.raw.ordinal() {
            1 => WirePizzaOrPastaMut::Pizza(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            2 => WirePizzaOrPastaMut::Pasta(unsafe { self.raw.get_mut().deref_mut_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WirePizzaOrPasta<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    crate::WirePizza<'buf>: ::fidl::Decode<___D>,
    crate::WirePasta<'buf>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, crate::WirePizza<'buf>>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, crate::WirePasta<'buf>>(raw, decoder)?,

            ord => return Err(fidl::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WirePizzaOrPasta<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WirePizza<'buf>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<crate::WirePasta<'buf>>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalPizzaOrPasta<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalPizzaOrPasta<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WirePizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WirePizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WirePizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(WirePizzaOrPasta {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalPizzaOrPasta<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalPizzaOrPasta<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    crate::WirePizza<'buf>: ::fidl::Decode<___D>,
    crate::WirePasta<'buf>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, crate::WirePizza<'buf>>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, crate::WirePasta<'buf>>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalPizzaOrPasta<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]

pub enum ReverseOrdinalUnion {
    First(u32),
    Second(u32),
}

impl ::fidl::Encodable for ReverseOrdinalUnion {
    type Encoded<'buf> = WireReverseOrdinalUnion<'buf>;
}

impl<___E> ::fidl::Encode<___E> for ReverseOrdinalUnion
where
    ___E: ::fidl::Encoder + ?Sized,

    u32: ::fidl::Encode<___E>,
    u32: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireReverseOrdinalUnion { raw } = slot);

        match self {
            Self::First(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, u32>(value, 1, encoder, raw)?
            }
            Self::Second(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, u32>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<ReverseOrdinalUnion> {
    type EncodedOption<'buf> = WireOptionalReverseOrdinalUnion<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<ReverseOrdinalUnion>
where
    ___E: ::fidl::Encoder + ?Sized,
    ReverseOrdinalUnion: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalReverseOrdinalUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireReverseOrdinalUnion<'buf>> for ReverseOrdinalUnion {
    fn take_from(from: &mut WireReverseOrdinalUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::First(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Second(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalReverseOrdinalUnion<'buf>>
    for Option<Box<ReverseOrdinalUnion>>
{
    fn take_from(from: &mut WireOptionalReverseOrdinalUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireReverseOrdinalUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireReverseOrdinalUnionRef<'buf> {
    First(&'buf ::fidl::u32_le),
    Second(&'buf ::fidl::u32_le),
}

pub enum WireReverseOrdinalUnionMut<'buf> {
    First(&'buf mut ::fidl::u32_le),
    Second(&'buf mut ::fidl::u32_le),
}

impl WireReverseOrdinalUnion<'_> {
    pub fn as_ref(&self) -> WireReverseOrdinalUnionRef<'_> {
        match self.raw.ordinal() {
            1 => WireReverseOrdinalUnionRef::First(unsafe { self.raw.get().deref_unchecked() }),

            2 => WireReverseOrdinalUnionRef::Second(unsafe { self.raw.get().deref_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireReverseOrdinalUnionMut<'_> {
        match self.raw.ordinal() {
            1 => WireReverseOrdinalUnionMut::First(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => WireReverseOrdinalUnionMut::Second(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireReverseOrdinalUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::u32_le: ::fidl::Decode<___D>,
    ::fidl::u32_le: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::u32_le>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::u32_le>(raw, decoder)?,

            ord => return Err(fidl::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireReverseOrdinalUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl::u32_le>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::u32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalReverseOrdinalUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalReverseOrdinalUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireReverseOrdinalUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireReverseOrdinalUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireReverseOrdinalUnion<'buf>> {
        if self.is_some() {
            Some(WireReverseOrdinalUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalReverseOrdinalUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalReverseOrdinalUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::u32_le: ::fidl::Decode<___D>,
    ::fidl::u32_le: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::u32_le>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::u32_le>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalReverseOrdinalUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]

pub enum StrictBoundedUnion {
    V(Vec<u8>),
}

impl ::fidl::Encodable for StrictBoundedUnion {
    type Encoded<'buf> = WireStrictBoundedUnion<'buf>;
}

impl<___E> ::fidl::Encode<___E> for StrictBoundedUnion
where
    ___E: ::fidl::Encoder + ?Sized,

    Vec<u8>: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireStrictBoundedUnion { raw } = slot);

        match self {
            Self::V(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, Vec<u8>>(value, 1, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<StrictBoundedUnion> {
    type EncodedOption<'buf> = WireOptionalStrictBoundedUnion<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<StrictBoundedUnion>
where
    ___E: ::fidl::Encoder + ?Sized,
    StrictBoundedUnion: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalStrictBoundedUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireStrictBoundedUnion<'buf>> for StrictBoundedUnion {
    fn take_from(from: &mut WireStrictBoundedUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::V(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalStrictBoundedUnion<'buf>>
    for Option<Box<StrictBoundedUnion>>
{
    fn take_from(from: &mut WireOptionalStrictBoundedUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireStrictBoundedUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireStrictBoundedUnionRef<'buf> {
    V(&'buf ::fidl::WireVector<'buf, u8>),
}

pub enum WireStrictBoundedUnionMut<'buf> {
    V(&'buf mut ::fidl::WireVector<'buf, u8>),
}

impl WireStrictBoundedUnion<'_> {
    pub fn as_ref(&self) -> WireStrictBoundedUnionRef<'_> {
        match self.raw.ordinal() {
            1 => WireStrictBoundedUnionRef::V(unsafe { self.raw.get().deref_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireStrictBoundedUnionMut<'_> {
        match self.raw.ordinal() {
            1 => WireStrictBoundedUnionMut::V(unsafe { self.raw.get_mut().deref_mut_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireStrictBoundedUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::WireVector<'buf, u8>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireVector<'buf, u8>>(raw, decoder)?
            }

            ord => return Err(fidl::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireStrictBoundedUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl::WireVector<'buf, u8>>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictBoundedUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalStrictBoundedUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictBoundedUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireStrictBoundedUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireStrictBoundedUnion<'buf>> {
        if self.is_some() {
            Some(WireStrictBoundedUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalStrictBoundedUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalStrictBoundedUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::WireVector<'buf, u8>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => {
                ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireVector<'buf, u8>>(raw, decoder)?
            }

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalStrictBoundedUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]

pub enum StrictFoo {
    S(String),
    I(i32),
}

impl ::fidl::Encodable for StrictFoo {
    type Encoded<'buf> = WireStrictFoo<'buf>;
}

impl<___E> ::fidl::Encode<___E> for StrictFoo
where
    ___E: ::fidl::Encoder + ?Sized,

    String: ::fidl::Encode<___E>,
    i32: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireStrictFoo { raw } = slot);

        match self {
            Self::S(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, String>(value, 1, encoder, raw)?
            }
            Self::I(value) => ::fidl::RawWireUnion::encode_as::<___E, i32>(value, 2, encoder, raw)?,
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<StrictFoo> {
    type EncodedOption<'buf> = WireOptionalStrictFoo<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<StrictFoo>
where
    ___E: ::fidl::Encoder + ?Sized,
    StrictFoo: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalStrictFoo { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireStrictFoo<'buf>> for StrictFoo {
    fn take_from(from: &mut WireStrictFoo<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::S(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::I(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalStrictFoo<'buf>> for Option<Box<StrictFoo>> {
    fn take_from(from: &mut WireOptionalStrictFoo<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireStrictFoo<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireStrictFooRef<'buf> {
    S(&'buf ::fidl::WireString<'buf>),
    I(&'buf ::fidl::i32_le),
}

pub enum WireStrictFooMut<'buf> {
    S(&'buf mut ::fidl::WireString<'buf>),
    I(&'buf mut ::fidl::i32_le),
}

impl WireStrictFoo<'_> {
    pub fn as_ref(&self) -> WireStrictFooRef<'_> {
        match self.raw.ordinal() {
            1 => WireStrictFooRef::S(unsafe { self.raw.get().deref_unchecked() }),

            2 => WireStrictFooRef::I(unsafe { self.raw.get().deref_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireStrictFooMut<'_> {
        match self.raw.ordinal() {
            1 => WireStrictFooMut::S(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            2 => WireStrictFooMut::I(unsafe { self.raw.get_mut().deref_mut_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireStrictFoo<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
    ::fidl::i32_le: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,

            ord => return Err(fidl::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireStrictFoo<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl::WireString<'buf>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::i32_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictFoo<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalStrictFoo<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictFoo<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireStrictFoo<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireStrictFoo<'buf>> {
        if self.is_some() {
            Some(WireStrictFoo {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalStrictFoo<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalStrictFoo<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
    ::fidl::i32_le: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalStrictFoo<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]

pub enum StrictPizzaOrPasta {
    Pizza(crate::Pizza),
    Pasta(crate::Pasta),
}

impl ::fidl::Encodable for StrictPizzaOrPasta {
    type Encoded<'buf> = WireStrictPizzaOrPasta<'buf>;
}

impl<___E> ::fidl::Encode<___E> for StrictPizzaOrPasta
where
    ___E: ::fidl::Encoder + ?Sized,

    crate::Pizza: ::fidl::Encode<___E>,
    crate::Pasta: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireStrictPizzaOrPasta { raw } = slot);

        match self {
            Self::Pizza(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, crate::Pizza>(value, 1, encoder, raw)?
            }
            Self::Pasta(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, crate::Pasta>(value, 2, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<StrictPizzaOrPasta> {
    type EncodedOption<'buf> = WireOptionalStrictPizzaOrPasta<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<StrictPizzaOrPasta>
where
    ___E: ::fidl::Encoder + ?Sized,
    StrictPizzaOrPasta: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalStrictPizzaOrPasta { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireStrictPizzaOrPasta<'buf>> for StrictPizzaOrPasta {
    fn take_from(from: &mut WireStrictPizzaOrPasta<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Pizza(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Pasta(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalStrictPizzaOrPasta<'buf>>
    for Option<Box<StrictPizzaOrPasta>>
{
    fn take_from(from: &mut WireOptionalStrictPizzaOrPasta<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireStrictPizzaOrPasta<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireStrictPizzaOrPastaRef<'buf> {
    Pizza(&'buf crate::WirePizza<'buf>),
    Pasta(&'buf crate::WirePasta<'buf>),
}

pub enum WireStrictPizzaOrPastaMut<'buf> {
    Pizza(&'buf mut crate::WirePizza<'buf>),
    Pasta(&'buf mut crate::WirePasta<'buf>),
}

impl WireStrictPizzaOrPasta<'_> {
    pub fn as_ref(&self) -> WireStrictPizzaOrPastaRef<'_> {
        match self.raw.ordinal() {
            1 => WireStrictPizzaOrPastaRef::Pizza(unsafe { self.raw.get().deref_unchecked() }),

            2 => WireStrictPizzaOrPastaRef::Pasta(unsafe { self.raw.get().deref_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireStrictPizzaOrPastaMut<'_> {
        match self.raw.ordinal() {
            1 => WireStrictPizzaOrPastaMut::Pizza(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            2 => WireStrictPizzaOrPastaMut::Pasta(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireStrictPizzaOrPasta<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    crate::WirePizza<'buf>: ::fidl::Decode<___D>,
    crate::WirePasta<'buf>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, crate::WirePizza<'buf>>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, crate::WirePasta<'buf>>(raw, decoder)?,

            ord => return Err(fidl::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireStrictPizzaOrPasta<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WirePizza<'buf>>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<crate::WirePasta<'buf>>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictPizzaOrPasta<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalStrictPizzaOrPasta<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictPizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireStrictPizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireStrictPizzaOrPasta<'buf>> {
        if self.is_some() {
            Some(WireStrictPizzaOrPasta {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalStrictPizzaOrPasta<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalStrictPizzaOrPasta<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    crate::WirePizza<'buf>: ::fidl::Decode<___D>,
    crate::WirePasta<'buf>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, crate::WirePizza<'buf>>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, crate::WirePasta<'buf>>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalStrictPizzaOrPasta<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]

pub enum StrictSimpleUnion {
    I(i32),
    F(f32),
    S(String),
}

impl ::fidl::Encodable for StrictSimpleUnion {
    type Encoded<'buf> = WireStrictSimpleUnion<'buf>;
}

impl<___E> ::fidl::Encode<___E> for StrictSimpleUnion
where
    ___E: ::fidl::Encoder + ?Sized,

    i32: ::fidl::Encode<___E>,
    f32: ::fidl::Encode<___E>,
    String: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireStrictSimpleUnion { raw } = slot);

        match self {
            Self::I(value) => ::fidl::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?,
            Self::F(value) => ::fidl::RawWireUnion::encode_as::<___E, f32>(value, 2, encoder, raw)?,
            Self::S(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, String>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<StrictSimpleUnion> {
    type EncodedOption<'buf> = WireOptionalStrictSimpleUnion<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<StrictSimpleUnion>
where
    ___E: ::fidl::Encoder + ?Sized,
    StrictSimpleUnion: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalStrictSimpleUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireStrictSimpleUnion<'buf>> for StrictSimpleUnion {
    fn take_from(from: &mut WireStrictSimpleUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::I(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::F(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::S(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalStrictSimpleUnion<'buf>>
    for Option<Box<StrictSimpleUnion>>
{
    fn take_from(from: &mut WireOptionalStrictSimpleUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireStrictSimpleUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireStrictSimpleUnionRef<'buf> {
    I(&'buf ::fidl::i32_le),
    F(&'buf ::fidl::f32_le),
    S(&'buf ::fidl::WireString<'buf>),
}

pub enum WireStrictSimpleUnionMut<'buf> {
    I(&'buf mut ::fidl::i32_le),
    F(&'buf mut ::fidl::f32_le),
    S(&'buf mut ::fidl::WireString<'buf>),
}

impl WireStrictSimpleUnion<'_> {
    pub fn as_ref(&self) -> WireStrictSimpleUnionRef<'_> {
        match self.raw.ordinal() {
            1 => WireStrictSimpleUnionRef::I(unsafe { self.raw.get().deref_unchecked() }),

            2 => WireStrictSimpleUnionRef::F(unsafe { self.raw.get().deref_unchecked() }),

            3 => WireStrictSimpleUnionRef::S(unsafe { self.raw.get().deref_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireStrictSimpleUnionMut<'_> {
        match self.raw.ordinal() {
            1 => WireStrictSimpleUnionMut::I(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            2 => WireStrictSimpleUnionMut::F(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            3 => WireStrictSimpleUnionMut::S(unsafe { self.raw.get_mut().deref_mut_unchecked() }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireStrictSimpleUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i32_le: ::fidl::Decode<___D>,
    ::fidl::f32_le: ::fidl::Decode<___D>,
    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::f32_le>(raw, decoder)?,
            3 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,

            ord => return Err(fidl::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireStrictSimpleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl::i32_le>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::f32_le>().fmt(f) },
            3 => unsafe { self.raw.get().deref_unchecked::<::fidl::WireString<'buf>>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictSimpleUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalStrictSimpleUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictSimpleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireStrictSimpleUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireStrictSimpleUnion<'buf>> {
        if self.is_some() {
            Some(WireStrictSimpleUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalStrictSimpleUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalStrictSimpleUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i32_le: ::fidl::Decode<___D>,
    ::fidl::f32_le: ::fidl::Decode<___D>,
    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::f32_le>(raw, decoder)?,
            3 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalStrictSimpleUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]

pub enum StrictUnion {
    Primitive(i32),
    Stringneedsconstructor(String),
    Vectorstringalsoneedsconstructor(Vec<String>),
}

impl ::fidl::Encodable for StrictUnion {
    type Encoded<'buf> = WireStrictUnion<'buf>;
}

impl<___E> ::fidl::Encode<___E> for StrictUnion
where
    ___E: ::fidl::Encoder + ?Sized,

    i32: ::fidl::Encode<___E>,
    String: ::fidl::Encode<___E>,
    Vec<String>: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireStrictUnion { raw } = slot);

        match self {
            Self::Primitive(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }
            Self::Stringneedsconstructor(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }
            Self::Vectorstringalsoneedsconstructor(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, Vec<String>>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<StrictUnion> {
    type EncodedOption<'buf> = WireOptionalStrictUnion<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<StrictUnion>
where
    ___E: ::fidl::Encoder + ?Sized,
    StrictUnion: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalStrictUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireStrictUnion<'buf>> for StrictUnion {
    fn take_from(from: &mut WireStrictUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Primitive(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Stringneedsconstructor(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::Vectorstringalsoneedsconstructor(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalStrictUnion<'buf>> for Option<Box<StrictUnion>> {
    fn take_from(from: &mut WireOptionalStrictUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireStrictUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireStrictUnionRef<'buf> {
    Primitive(&'buf ::fidl::i32_le),
    Stringneedsconstructor(&'buf ::fidl::WireString<'buf>),
    Vectorstringalsoneedsconstructor(&'buf ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>),
}

pub enum WireStrictUnionMut<'buf> {
    Primitive(&'buf mut ::fidl::i32_le),
    Stringneedsconstructor(&'buf mut ::fidl::WireString<'buf>),
    Vectorstringalsoneedsconstructor(&'buf mut ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>),
}

impl WireStrictUnion<'_> {
    pub fn as_ref(&self) -> WireStrictUnionRef<'_> {
        match self.raw.ordinal() {
            1 => WireStrictUnionRef::Primitive(unsafe { self.raw.get().deref_unchecked() }),

            2 => WireStrictUnionRef::Stringneedsconstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),

            3 => WireStrictUnionRef::Vectorstringalsoneedsconstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireStrictUnionMut<'_> {
        match self.raw.ordinal() {
            1 => WireStrictUnionMut::Primitive(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            2 => WireStrictUnionMut::Stringneedsconstructor(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            3 => WireStrictUnionMut::Vectorstringalsoneedsconstructor(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireStrictUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i32_le: ::fidl::Decode<___D>,
    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
    ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,
            3 => ::fidl::RawWireUnion::decode_as::<
                ___D,
                ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>,
            >(raw, decoder)?,

            ord => return Err(fidl::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireStrictUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl::i32_le>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::WireString<'buf>>().fmt(f) },
            3 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<::fidl::WireVector<'buf, ::fidl::WireString<'buf>>>()
                    .fmt(f)
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalStrictUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalStrictUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireStrictUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireStrictUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireStrictUnion<'buf>> {
        if self.is_some() {
            Some(WireStrictUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalStrictUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalStrictUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i32_le: ::fidl::Decode<___D>,
    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
    ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,
            3 => ::fidl::RawWireUnion::decode_as::<
                ___D,
                ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>,
            >(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalStrictUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct StructWithNullableUnion {
    pub x1: Option<Box<crate::OlderSimpleUnion>>,
}

impl ::fidl::Encodable for StructWithNullableUnion {
    type Encoded<'buf> = WireStructWithNullableUnion<'buf>;
}

impl<___E> ::fidl::Encode<___E> for StructWithNullableUnion
where
    Option<Box<crate::OlderSimpleUnion>>: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge! {
            let Self::Encoded {
                x1,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.x1, encoder, x1)?;
        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<StructWithNullableUnion> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireStructWithNullableUnion<'buf>>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<StructWithNullableUnion>
where
    ___E: ::fidl::Encoder + ?Sized,
    StructWithNullableUnion: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        if let Some(inner) = this {
            ::fidl::EncoderExt::encode(encoder, inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireStructWithNullableUnion<'buf>> for StructWithNullableUnion {
    fn take_from(from: &mut WireStructWithNullableUnion<'buf>) -> Self {
        Self { x1: ::fidl::TakeFrom::take_from(&mut from.x1) }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireStructWithNullableUnion<'buf> {
    pub x1: crate::WireOptionalOlderSimpleUnion<'buf>,
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireStructWithNullableUnion<'buf>
where
    ___D: ?Sized,

    crate::WireOptionalOlderSimpleUnion<'buf>: ::fidl::Decode<___D>,
{
    fn decode(slot: ::fidl::Slot<'_, Self>, decoder: &mut ___D) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge! {
            let Self {
                mut x1,
            } = slot;
        }
        ::fidl::Decode::decode(x1.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse {
    pub xu: crate::StrictBoundedUnion,
}

impl ::fidl::Encodable for TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse {
    type Encoded<'buf> = WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'buf>;
}

impl<___E> ::fidl::Encode<___E> for TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse
where
    crate::StrictBoundedUnion: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge! {
            let Self::Encoded {
                xu,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.xu, encoder, xu)?;
        Ok(())
    }
}

impl ::fidl::EncodableOption
    for Box<TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse>
{
    type EncodedOption<'buf> = ::fidl::WireBox<
        'buf,
        WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'buf>,
    >;
}

impl<___E> ::fidl::EncodeOption<___E>
    for Box<TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse>
where
    ___E: ::fidl::Encoder + ?Sized,
    TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        if let Some(inner) = this {
            ::fidl::EncoderExt::encode(encoder, inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl::TakeFrom<WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'buf>>
    for TestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse
{
    fn take_from(
        from: &mut WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'buf>,
    ) -> Self {
        Self { xu: ::fidl::TakeFrom::take_from(&mut from.xu) }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'buf> {
    pub xu: crate::WireStrictBoundedUnion<'buf>,
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D>
    for WireTestProtocolStrictUnionHenceResponseMayBeStackAllocatedResponse<'buf>
where
    ___D: ?Sized,

    crate::WireStrictBoundedUnion<'buf>: ::fidl::Decode<___D>,
{
    fn decode(slot: ::fidl::Slot<'_, Self>, decoder: &mut ___D) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge! {
            let Self {
                mut xu,
            } = slot;
        }
        ::fidl::Decode::decode(xu.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]
pub struct TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse {
    pub xu: crate::OlderSimpleUnion,
}

impl ::fidl::Encodable for TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse {
    type Encoded<'buf> =
        WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'buf>;
}

impl<___E> ::fidl::Encode<___E>
    for TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse
where
    crate::OlderSimpleUnion: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge! {
            let Self::Encoded {
                xu,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.xu, encoder, xu)?;
        Ok(())
    }
}

impl ::fidl::EncodableOption
    for Box<TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse>
{
    type EncodedOption<'buf> = ::fidl::WireBox<
        'buf,
        WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'buf>,
    >;
}

impl<___E> ::fidl::EncodeOption<___E>
    for Box<TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse>
where
    ___E: ::fidl::Encoder + ?Sized,
    TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        if let Some(inner) = this {
            ::fidl::EncoderExt::encode(encoder, inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf>
    ::fidl::TakeFrom<WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'buf>>
    for TestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse
{
    fn take_from(
        from: &mut WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'buf>,
    ) -> Self {
        Self { xu: ::fidl::TakeFrom::take_from(&mut from.xu) }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'buf> {
    pub xu: crate::WireOlderSimpleUnion<'buf>,
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D>
    for WireTestProtocolFlexibleUnionHenceResponseMustBeHeapAllocatedResponse<'buf>
where
    ___D: ?Sized,

    crate::WireOlderSimpleUnion<'buf>: ::fidl::Decode<___D>,
{
    fn decode(slot: ::fidl::Slot<'_, Self>, decoder: &mut ___D) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge! {
            let Self {
                mut xu,
            } = slot;
        }
        ::fidl::Decode::decode(xu.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum Union {
    Primitive(i32),
    Stringneedsconstructor(String),
    Vectorstringalsoneedsconstructor(Vec<String>),
}

impl ::fidl::Encodable for Union {
    type Encoded<'buf> = WireUnion<'buf>;
}

impl<___E> ::fidl::Encode<___E> for Union
where
    ___E: ::fidl::Encoder + ?Sized,

    i32: ::fidl::Encode<___E>,
    String: ::fidl::Encode<___E>,
    Vec<String>: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireUnion { raw } = slot);

        match self {
            Self::Primitive(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, i32>(value, 1, encoder, raw)?
            }
            Self::Stringneedsconstructor(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, String>(value, 2, encoder, raw)?
            }
            Self::Vectorstringalsoneedsconstructor(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, Vec<String>>(value, 3, encoder, raw)?
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<Union> {
    type EncodedOption<'buf> = WireOptionalUnion<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<Union>
where
    ___E: ::fidl::Encoder + ?Sized,
    Union: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalUnion { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireUnion<'buf>> for Union {
    fn take_from(from: &mut WireUnion<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Primitive(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            2 => Self::Stringneedsconstructor(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            3 => Self::Vectorstringalsoneedsconstructor(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalUnion<'buf>> for Option<Box<Union>> {
    fn take_from(from: &mut WireOptionalUnion<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireUnionRef<'buf> {
    Primitive(&'buf ::fidl::i32_le),
    Stringneedsconstructor(&'buf ::fidl::WireString<'buf>),
    Vectorstringalsoneedsconstructor(&'buf ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>),
}

pub enum WireUnionMut<'buf> {
    Primitive(&'buf mut ::fidl::i32_le),
    Stringneedsconstructor(&'buf mut ::fidl::WireString<'buf>),
    Vectorstringalsoneedsconstructor(&'buf mut ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>),
}

impl WireUnion<'_> {
    pub fn as_ref(&self) -> WireUnionRef<'_> {
        match self.raw.ordinal() {
            1 => WireUnionRef::Primitive(unsafe { self.raw.get().deref_unchecked() }),

            2 => WireUnionRef::Stringneedsconstructor(unsafe { self.raw.get().deref_unchecked() }),

            3 => WireUnionRef::Vectorstringalsoneedsconstructor(unsafe {
                self.raw.get().deref_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }

    pub fn as_mut(&mut self) -> WireUnionMut<'_> {
        match self.raw.ordinal() {
            1 => WireUnionMut::Primitive(unsafe { self.raw.get_mut().deref_mut_unchecked() }),

            2 => WireUnionMut::Stringneedsconstructor(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),

            3 => WireUnionMut::Vectorstringalsoneedsconstructor(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i32_le: ::fidl::Decode<___D>,
    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
    ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,
            3 => ::fidl::RawWireUnion::decode_as::<
                ___D,
                ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>,
            >(raw, decoder)?,

            ord => return Err(fidl::DecodeError::InvalidUnionOrdinal(ord as usize)),
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl::i32_le>().fmt(f) },
            2 => unsafe { self.raw.get().deref_unchecked::<::fidl::WireString<'buf>>().fmt(f) },
            3 => unsafe {
                self.raw
                    .get()
                    .deref_unchecked::<::fidl::WireVector<'buf, ::fidl::WireString<'buf>>>()
                    .fmt(f)
            },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnion<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalUnion<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireUnion<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnion<'buf>> {
        if self.is_some() {
            Some(WireUnion {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalUnion<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalUnion<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i32_le: ::fidl::Decode<___D>,
    ::fidl::WireString<'buf>: ::fidl::Decode<___D>,
    ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i32_le>(raw, decoder)?,
            2 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::WireString<'buf>>(raw, decoder)?,
            3 => ::fidl::RawWireUnion::decode_as::<
                ___D,
                ::fidl::WireVector<'buf, ::fidl::WireString<'buf>>,
            >(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalUnion<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]

pub enum UnionContainingEmptyStruct {
    Empty(crate::Empty),
    Unknown(u64),
}

impl ::fidl::Encodable for UnionContainingEmptyStruct {
    type Encoded<'buf> = WireUnionContainingEmptyStruct<'buf>;
}

impl<___E> ::fidl::Encode<___E> for UnionContainingEmptyStruct
where
    ___E: ::fidl::Encoder + ?Sized,

    crate::Empty: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireUnionContainingEmptyStruct { raw } = slot);

        match self {
            Self::Empty(value) => {
                ::fidl::RawWireUnion::encode_as::<___E, crate::Empty>(value, 1, encoder, raw)?
            }

            Self::Unknown(ordinal) => {
                return Err(::fidl::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<UnionContainingEmptyStruct> {
    type EncodedOption<'buf> = WireOptionalUnionContainingEmptyStruct<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<UnionContainingEmptyStruct>
where
    ___E: ::fidl::Encoder + ?Sized,
    UnionContainingEmptyStruct: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalUnionContainingEmptyStruct { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireUnionContainingEmptyStruct<'buf>> for UnionContainingEmptyStruct {
    fn take_from(from: &mut WireUnionContainingEmptyStruct<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::Empty(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalUnionContainingEmptyStruct<'buf>>
    for Option<Box<UnionContainingEmptyStruct>>
{
    fn take_from(from: &mut WireOptionalUnionContainingEmptyStruct<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireUnionContainingEmptyStruct<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireUnionContainingEmptyStructRef<'buf> {
    Empty(&'buf crate::WireEmpty),
    Unknown(u64),
}

pub enum WireUnionContainingEmptyStructMut<'buf> {
    Empty(&'buf mut crate::WireEmpty),
    Unknown(u64),
}

impl WireUnionContainingEmptyStruct<'_> {
    pub fn as_ref(&self) -> WireUnionContainingEmptyStructRef<'_> {
        match self.raw.ordinal() {
            1 => WireUnionContainingEmptyStructRef::Empty(unsafe {
                self.raw.get().deref_unchecked()
            }),
            unknown => WireUnionContainingEmptyStructRef::Unknown(unknown),
        }
    }

    pub fn as_mut(&mut self) -> WireUnionContainingEmptyStructMut<'_> {
        match self.raw.ordinal() {
            1 => WireUnionContainingEmptyStructMut::Empty(unsafe {
                self.raw.get_mut().deref_mut_unchecked()
            }),
            unknown => WireUnionContainingEmptyStructMut::Unknown(unknown),
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireUnionContainingEmptyStruct<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    crate::WireEmpty: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, crate::WireEmpty>(raw, decoder)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireUnionContainingEmptyStruct<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<crate::WireEmpty>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnionContainingEmptyStruct<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalUnionContainingEmptyStruct<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnionContainingEmptyStruct<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireUnionContainingEmptyStruct<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnionContainingEmptyStruct<'buf>> {
        if self.is_some() {
            Some(WireUnionContainingEmptyStruct {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalUnionContainingEmptyStruct<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalUnionContainingEmptyStruct<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    crate::WireEmpty: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, crate::WireEmpty>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalUnionContainingEmptyStruct<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}

#[derive(Clone, Debug)]
pub struct UnionSandwich {
    pub a: u32,
    pub u: crate::ExplicitFlexibleUnion,
    pub b: u32,
}

impl ::fidl::Encodable for UnionSandwich {
    type Encoded<'buf> = WireUnionSandwich<'buf>;
}

impl<___E> ::fidl::Encode<___E> for UnionSandwich
where
    u32: ::fidl::Encode<___E>,
    crate::ExplicitFlexibleUnion: ::fidl::Encode<___E>,
    u32: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge! {
            let Self::Encoded {
                a,
                u,
                b,
            } = slot;
        }
        ::fidl::Encode::encode(&mut self.a, encoder, a)?;
        ::fidl::Encode::encode(&mut self.u, encoder, u)?;
        ::fidl::Encode::encode(&mut self.b, encoder, b)?;
        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<UnionSandwich> {
    type EncodedOption<'buf> = ::fidl::WireBox<'buf, WireUnionSandwich<'buf>>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<UnionSandwich>
where
    ___E: ::fidl::Encoder + ?Sized,
    UnionSandwich: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        if let Some(inner) = this {
            ::fidl::EncoderExt::encode(encoder, inner)?;
            ::fidl::WireBox::encode_present(slot);
        } else {
            ::fidl::WireBox::encode_absent(slot);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireUnionSandwich<'buf>> for UnionSandwich {
    fn take_from(from: &mut WireUnionSandwich<'buf>) -> Self {
        Self {
            a: ::fidl::TakeFrom::take_from(&mut from.a),
            u: ::fidl::TakeFrom::take_from(&mut from.u),
            b: ::fidl::TakeFrom::take_from(&mut from.b),
        }
    }
}

#[derive(Debug)]
#[repr(C)]
pub struct WireUnionSandwich<'buf> {
    pub a: ::fidl::u32_le,
    pub u: crate::WireExplicitFlexibleUnion<'buf>,
    pub b: ::fidl::u32_le,
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireUnionSandwich<'buf>
where
    ___D: ?Sized,

    ::fidl::u32_le: ::fidl::Decode<___D>,
    crate::WireExplicitFlexibleUnion<'buf>: ::fidl::Decode<___D>,
    ::fidl::u32_le: ::fidl::Decode<___D>,
{
    fn decode(slot: ::fidl::Slot<'_, Self>, decoder: &mut ___D) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge! {
            let Self {
                mut a,
                mut u,
                mut b,
            } = slot;
        }
        ::fidl::Decode::decode(a.as_mut(), decoder)?;
        ::fidl::Decode::decode(u.as_mut(), decoder)?;
        ::fidl::Decode::decode(b.as_mut(), decoder)?;
        Ok(())
    }
}

#[derive(Clone, Debug)]

pub enum UnionWithAttributes {
    X(i64),
    Unknown(u64),
}

impl ::fidl::Encodable for UnionWithAttributes {
    type Encoded<'buf> = WireUnionWithAttributes<'buf>;
}

impl<___E> ::fidl::Encode<___E> for UnionWithAttributes
where
    ___E: ::fidl::Encoder + ?Sized,

    i64: ::fidl::Encode<___E>,
{
    fn encode(
        &mut self,
        encoder: &mut ___E,
        slot: ::fidl::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireUnionWithAttributes { raw } = slot);

        match self {
            Self::X(value) => ::fidl::RawWireUnion::encode_as::<___E, i64>(value, 1, encoder, raw)?,

            Self::Unknown(ordinal) => {
                return Err(::fidl::EncodeError::UnknownUnionOrdinal(*ordinal as usize))
            }
        }

        Ok(())
    }
}

impl ::fidl::EncodableOption for Box<UnionWithAttributes> {
    type EncodedOption<'buf> = WireOptionalUnionWithAttributes<'buf>;
}

impl<___E> ::fidl::EncodeOption<___E> for Box<UnionWithAttributes>
where
    ___E: ::fidl::Encoder + ?Sized,
    UnionWithAttributes: ::fidl::Encode<___E>,
{
    fn encode_option(
        this: Option<&mut Self>,
        encoder: &mut ___E,
        mut slot: ::fidl::Slot<'_, Self::EncodedOption<'_>>,
    ) -> Result<(), ::fidl::EncodeError> {
        ::fidl::munge!(let WireOptionalUnionWithAttributes { raw } = slot.as_mut());

        if let Some(inner) = this {
            let slot = unsafe { ::fidl::Slot::new_unchecked(slot.as_mut_ptr().cast()) };
            ::fidl::Encode::encode(&mut **inner, encoder, slot)?;
        } else {
            ::fidl::RawWireUnion::encode_absent(raw);
        }

        Ok(())
    }
}

impl<'buf> ::fidl::TakeFrom<WireUnionWithAttributes<'buf>> for UnionWithAttributes {
    fn take_from(from: &mut WireUnionWithAttributes<'buf>) -> Self {
        match from.raw.ordinal() {
            1 => Self::X(::fidl::TakeFrom::take_from(unsafe {
                from.raw.get_mut().deref_mut_unchecked()
            })),

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

impl<'buf> ::fidl::TakeFrom<WireOptionalUnionWithAttributes<'buf>>
    for Option<Box<UnionWithAttributes>>
{
    fn take_from(from: &mut WireOptionalUnionWithAttributes<'buf>) -> Self {
        if let Some(inner) = from.as_mut() {
            Some(::fidl::TakeFrom::take_from(inner))
        } else {
            None
        }
    }
}

#[repr(transparent)]
pub struct WireUnionWithAttributes<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

pub enum WireUnionWithAttributesRef<'buf> {
    X(&'buf ::fidl::i64_le),
    Unknown(u64),
}

pub enum WireUnionWithAttributesMut<'buf> {
    X(&'buf mut ::fidl::i64_le),
    Unknown(u64),
}

impl WireUnionWithAttributes<'_> {
    pub fn as_ref(&self) -> WireUnionWithAttributesRef<'_> {
        match self.raw.ordinal() {
            1 => WireUnionWithAttributesRef::X(unsafe { self.raw.get().deref_unchecked() }),
            unknown => WireUnionWithAttributesRef::Unknown(unknown),
        }
    }

    pub fn as_mut(&mut self) -> WireUnionWithAttributesMut<'_> {
        match self.raw.ordinal() {
            1 => WireUnionWithAttributesMut::X(unsafe { self.raw.get_mut().deref_mut_unchecked() }),
            unknown => WireUnionWithAttributesMut::Unknown(unknown),
        }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireUnionWithAttributes<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i64_le: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i64_le>(raw, decoder)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireUnionWithAttributes<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        match self.raw.ordinal() {
            1 => unsafe { self.raw.get().deref_unchecked::<::fidl::i64_le>().fmt(f) },

            _ => unsafe { ::core::hint::unreachable_unchecked() },
        }
    }
}

#[repr(transparent)]
pub struct WireOptionalUnionWithAttributes<'buf> {
    raw: ::fidl::RawWireUnion<'buf>,
}

impl<'buf> WireOptionalUnionWithAttributes<'buf> {
    pub fn is_some(&self) -> bool {
        self.raw.is_some()
    }

    pub fn is_none(&self) -> bool {
        self.raw.is_none()
    }

    pub fn as_ref(&self) -> Option<&WireUnionWithAttributes<'buf>> {
        if self.is_some() {
            Some(unsafe { &*(self as *const Self).cast() })
        } else {
            None
        }
    }

    pub fn as_mut(&mut self) -> Option<&mut WireUnionWithAttributes<'buf>> {
        if self.is_some() {
            Some(unsafe { &mut *(self as *mut Self).cast() })
        } else {
            None
        }
    }

    pub fn take(&mut self) -> Option<WireUnionWithAttributes<'buf>> {
        if self.is_some() {
            Some(WireUnionWithAttributes {
                raw: ::core::mem::replace(&mut self.raw, ::fidl::RawWireUnion::null()),
            })
        } else {
            None
        }
    }
}

impl<'buf> Default for WireOptionalUnionWithAttributes<'buf> {
    fn default() -> Self {
        Self { raw: ::fidl::RawWireUnion::null() }
    }
}

unsafe impl<'buf, ___D> ::fidl::Decode<___D> for WireOptionalUnionWithAttributes<'buf>
where
    ___D: ::fidl::Decoder<'buf> + ?Sized,

    ::fidl::i64_le: ::fidl::Decode<___D>,
{
    fn decode(
        mut slot: ::fidl::Slot<'_, Self>,
        decoder: &mut ___D,
    ) -> Result<(), ::fidl::DecodeError> {
        ::fidl::munge!(let Self { mut raw } = slot.as_mut());
        match ::fidl::RawWireUnion::encoded_ordinal(raw.as_mut()) {
            1 => ::fidl::RawWireUnion::decode_as::<___D, ::fidl::i64_le>(raw, decoder)?,

            0 => ::fidl::RawWireUnion::decode_absent(raw)?,
            _ => ::fidl::RawWireUnion::decode_unknown(raw, decoder)?,
        }

        Ok(())
    }
}

impl<'buf> ::core::fmt::Debug for WireOptionalUnionWithAttributes<'buf> {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::fmt::Result {
        self.as_ref().fmt(f)
    }
}
