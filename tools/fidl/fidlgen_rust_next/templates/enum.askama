{% let name = enm.name.decl_name().camel() %}
{% let natural_int = compiler.natural_int(enm.ty) %}
{% let wire_int = compiler.wire_int(enm.ty) %}

{% if let Some(doc) = enm.attributes.doc_string() %}
    #[doc = "{{ doc.escape_default() }}"]
{% endif %}
#[derive(
    Clone,
    Copy,
    {% if compiler.config.emit_debug_impls -%}
        Debug,
    {%- endif %}
)]
#[repr({{ natural_int }})]
pub enum {{ name }} {
    {% for member in enm.members -%}
        {{ member.name.camel() }} = {{ member.value.value }},
    {%- endfor %}
    {%- if !enm.is_strict -%}
        Unknown({{ natural_int }}),
    {%- endif %}
}

impl ::fidl_next::Encodable for {{ name }} {
    type Encoded<'buf> = Wire{{ name }};
}

impl<___E> ::fidl_next::Encode<___E> for {{ name }}
where
    ___E: ?Sized,
{
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let Wire{{ name }} { mut value } = slot);
        *value = {{ wire_int }}::from(match *self {
            {% for member in enm.members %}
                Self::{{ member.name.camel() }} => {{ member.value.value }},
            {% endfor %}
            {% if !enm.is_strict %}
                Self::Unknown(value) => value,
            {% endif %}
        });

        Ok(())
    }
}

impl ::core::convert::From<Wire{{ name }}> for {{ name }} {
    fn from(wire: Wire{{ name }}) -> Self {
        match {{ natural_int }}::from(wire.value) {
            {% for member in enm.members %}
                {{ member.value.value }} => Self::{{ member.name.camel() }},
            {% endfor %}
            {% if enm.is_strict %}
                _ => unsafe { ::core::hint::unreachable_unchecked() },
            {% else %}
                value => Self::Unknown(value),
            {% endif %}
        }
    }
}

impl ::fidl_next::TakeFrom<Wire{{ name }}> for {{ name }} {
    fn take_from(from: &mut Wire{{ name }}) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`{{ name }}`].
#[derive(
    Clone,
    Copy,
    {% if compiler.config.emit_debug_impls -%}
        Debug,
    {%- endif %}
)]
#[repr(transparent)]
pub struct Wire{{ name }} {
    value: {{ wire_int }},
}

impl Wire{{ name }} {
    {% for member in enm.members %}
        pub const {{ member.name.screaming_snake() }}: Wire{{ name }} = Wire{{ name }} {
            value:
            {% match enm.ty %}
                {% when IntType::Int8 %} {{ member.value.value }}
                {% when IntType::Uint8 %} {{ member.value.value }}
                {% else %} {{ wire_int }}::from_native({{ member.value.value }})
            {% endmatch %}
        };
    {% endfor %}
}

unsafe impl<___D> ::fidl_next::Decode<___D> for Wire{{ name }}
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _ : &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        {% if enm.is_strict %}
            ::fidl_next::munge!(let Self { value } = slot);

            match {{ natural_int }}::from(*value) {
                {% for member in enm.members %}
                    | {{ member.value.value }}
                {% endfor %}
                => (),
                unknown => return Err(::fidl_next::DecodeError::InvalidEnumOrdinal(
                    unknown as i128,
                )),
            }
        {% endif %}

        Ok(())
    }
}

impl ::core::convert::From<{{ name }}> for Wire{{ name }} {
    fn from(natural: {{ name }}) -> Self {
        match natural {
            {% for member in enm.members %}
                {{ name }}::{{ member.name.camel() }} => Wire{{ name }}::{{ member.name.screaming_snake() }},
            {% endfor %}
            {% if !enm.is_strict %}
                {{ name }}::Unknown(value) => Wire{{ name }} {
                    value: {{ wire_int }}::from(value),
                }
            {% endif %}
        }
    }
}
