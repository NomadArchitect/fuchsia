{% let name = bits.name.decl_name().camel() %}
{% let subtype = self.subtype() %}
{% let natural_subtype = compiler.natural_prim(subtype) %}
{% let wire_subtype = compiler.wire_prim(subtype) %}

{% if let Some(doc) = bits.attributes.doc_string() %}
    #[doc = "{{ doc.escape_default() }}"]
{% endif %}
::fidl_next::bitflags! {
    #[derive(
        Clone,
        Copy,
        {% if compiler.config.emit_debug_impls -%}
            Debug,
        {%- endif %}
        PartialEq,
        Eq,
        Hash,
    )]
    pub struct {{ name }}: {{ natural_subtype }} {
        {% for member in bits.members -%}
            {%- if let Some(doc) = member.attributes.doc_string() -%}
                #[doc = "{{ doc.escape_default() }}"]
            {%- endif -%}
            const {{ member.name.screaming_snake() }} = {{ member.value.value }};
        {% endfor %}
        {%- if !bits.is_strict -%}
            const _ = !0;
        {%- endif %}
    }
}

impl ::fidl_next::Encodable for {{ name }} {
    type Encoded<'buf> = Wire{{ name }};
}

impl<___E> ::fidl_next::Encode<___E> for {{ name }}
where
    ___E: ?Sized,
{
    fn encode(
        &mut self,
        _: &mut ___E,
        slot: ::fidl_next::Slot<'_, Self::Encoded<'_>>,
    ) -> Result<(), ::fidl_next::EncodeError> {
        ::fidl_next::munge!(let Wire{{ name }} { mut value } = slot);
        *value = {{ wire_subtype }}::from(self.bits());
        Ok(())
    }
}

impl ::core::convert::From<Wire{{ name }}> for {{ name }} {
    fn from(wire: Wire{{ name }}) -> Self {
        Self::from_bits_retain({{ natural_subtype }}::from(wire.value))
    }
}

impl ::fidl_next::TakeFrom<Wire{{ name }}> for {{ name }} {
    fn take_from(from: &mut Wire{{ name }}) -> Self {
        Self::from(*from)
    }
}

/// The wire type corresponding to [`{{ name }}`].
#[derive(
    Clone,
    Copy,
    {% if compiler.config.emit_debug_impls -%}
        Debug,
    {%- endif %}
)]
#[repr(transparent)]
pub struct Wire{{ name }} {
    value: {{ wire_subtype }},
}

unsafe impl<___D> ::fidl_next::Decode<___D> for Wire{{ name }}
where
    ___D: ?Sized,
{
    fn decode(
        slot: ::fidl_next::Slot<'_, Self>,
        _: &mut ___D,
    ) -> Result<(), ::fidl_next::DecodeError> {
        {% if bits.is_strict %}
            ::fidl_next::munge!(let Self { value } = slot);
            let set = {{ natural_subtype }}::from(*value);
            if set & !{{ name }}::all().bits() != 0 {
                return Err(::fidl_next::DecodeError::InvalidBits {
                    expected: {{ name }}::all().bits() as usize,
                    actual: set as usize,
                });
            }
        {% endif %}
        Ok(())
    }
}

impl ::core::convert::From<{{ name }}> for Wire{{ name }} {
    fn from(natural: {{ name }}) -> Self {
        Self {
            value: {{ wire_subtype }}::from(natural.bits()),
        }
    }
}
