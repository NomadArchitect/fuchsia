# WARNING: This file is machine generated by fidlgen.

from __future__ import annotations

from dataclasses import dataclass

# TODO(https://fxbug.dev/346628306): Enable type checking here once fidl_codec has stubs
from fidl_codec import add_ir_path, encode_fidl_object  # type: ignore
import sys
import typing
import enum

import fidl

_ir_path = fidl._library.get_fidl_ir_map()["test.protocols"]
add_ir_path(_ir_path)


@dataclass
class ChannelProtocolEventARequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    a: int | None
    b: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ChannelProtocolEventARequest"
    __fidl_raw_type__ = "test.protocols/ChannelProtocolEventARequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/ChannelProtocolEventARequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,
                "b": None,
            }
        )


@dataclass
class ChannelProtocolMethodARequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    a: int | None
    b: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ChannelProtocolMethodARequest"
    __fidl_raw_type__ = "test.protocols/ChannelProtocolMethodARequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/ChannelProtocolMethodARequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,
                "b": None,
            }
        )


@dataclass
class ChannelProtocolMethodBRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    a: int | None
    b: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ChannelProtocolMethodBRequest"
    __fidl_raw_type__ = "test.protocols/ChannelProtocolMethodBRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/ChannelProtocolMethodBRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,
                "b": None,
            }
        )


@dataclass
class ChannelProtocolMethodBResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    result: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ChannelProtocolMethodBResponse"
    __fidl_raw_type__ = "test.protocols/ChannelProtocolMethodBResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/ChannelProtocolMethodBResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "result": None,
            }
        )


@dataclass
class ChannelProtocolMutateSocketRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    a: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ChannelProtocolMutateSocketRequest"
    __fidl_raw_type__ = "test.protocols/ChannelProtocolMutateSocketRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/ChannelProtocolMutateSocketRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,
            }
        )


@dataclass
class ChannelProtocolMutateSocketResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    b: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ChannelProtocolMutateSocketResponse"
    __fidl_raw_type__ = "test.protocols/ChannelProtocolMutateSocketResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/ChannelProtocolMutateSocketResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "b": None,
            }
        )


@dataclass
class ChannelProtocolTakeHandleRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    h: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ChannelProtocolTakeHandleRequest"
    __fidl_raw_type__ = "test.protocols/ChannelProtocolTakeHandleRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/ChannelProtocolTakeHandleRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "h": None,
            }
        )


@dataclass
class HandleRightsProtocolAnEventRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    h: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "HandleRightsProtocolAnEventRequest"
    __fidl_raw_type__ = "test.protocols/HandleRightsProtocolAnEventRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/HandleRightsProtocolAnEventRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "h": None,
            }
        )


@dataclass
class HandleRightsProtocolNoResponseMethodRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    h: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "HandleRightsProtocolNoResponseMethodRequest"
    __fidl_raw_type__ = (
        "test.protocols/HandleRightsProtocolNoResponseMethodRequest"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/HandleRightsProtocolNoResponseMethodRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "h": None,
            }
        )


@dataclass
class HandleRightsProtocolResponseMethodRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    h: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "HandleRightsProtocolResponseMethodRequest"
    __fidl_raw_type__ = (
        "test.protocols/HandleRightsProtocolResponseMethodRequest"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/HandleRightsProtocolResponseMethodRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "h": None,
            }
        )


@dataclass
class HandleRightsProtocolResponseMethodResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    h: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "HandleRightsProtocolResponseMethodResponse"
    __fidl_raw_type__ = (
        "test.protocols/HandleRightsProtocolResponseMethodResponse"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/HandleRightsProtocolResponseMethodResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "h": None,
            }
        )


@dataclass
class ManyParametersFifteenRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    p1: bool | None
    p2: bool | None
    p3: bool | None
    p4: bool | None
    p5: bool | None
    p6: bool | None
    p7: bool | None
    p8: bool | None
    p9: bool | None
    p10: bool | None
    p11: bool | None
    p12: bool | None
    p13: bool | None
    p14: bool | None
    p15: bool | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ManyParametersFifteenRequest"
    __fidl_raw_type__ = "test.protocols/ManyParametersFifteenRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/ManyParametersFifteenRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "p1": None,
                "p2": None,
                "p3": None,
                "p4": None,
                "p5": None,
                "p6": None,
                "p7": None,
                "p8": None,
                "p9": None,
                "p10": None,
                "p11": None,
                "p12": None,
                "p13": None,
                "p14": None,
                "p15": None,
            }
        )


@dataclass
class MethodWithUnionUnionMethodRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    u: TheUnion | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "MethodWithUnionUnionMethodRequest"
    __fidl_raw_type__ = "test.protocols/MethodWithUnionUnionMethodRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/MethodWithUnionUnionMethodRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "u": None,
            }
        )


@dataclass
class MethodWithUnionUnionMethodResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    u: typing.Optional[TheUnion] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "MethodWithUnionUnionMethodResponse"
    __fidl_raw_type__ = "test.protocols/MethodWithUnionUnionMethodResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/MethodWithUnionUnionMethodResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "u": None,
            }
        )


@dataclass
class ProtocolEnds:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    client: int | None
    server: int | None
    client_opt: typing.Optional[int] | None
    server_opt: typing.Optional[int] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "ProtocolEnds"
    __fidl_raw_type__ = "test.protocols/ProtocolEnds"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.protocols", "test.protocols/ProtocolEnds"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "client": None,
                "server": None,
                "client_opt": None,
                "server_opt": None,
            }
        )


@dataclass
class WithAndWithoutRequestResponseNoRequestWithResponseResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    ret: str | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithAndWithoutRequestResponseNoRequestWithResponseResponse"
    __fidl_raw_type__ = "test.protocols/WithAndWithoutRequestResponseNoRequestWithResponseResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithAndWithoutRequestResponseNoRequestWithResponseResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "ret": None,
            }
        )


@dataclass
class WithAndWithoutRequestResponseOnWithResponseRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    ret: str | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithAndWithoutRequestResponseOnWithResponseRequest"
    __fidl_raw_type__ = (
        "test.protocols/WithAndWithoutRequestResponseOnWithResponseRequest"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithAndWithoutRequestResponseOnWithResponseRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "ret": None,
            }
        )


@dataclass
class WithAndWithoutRequestResponseWithRequestEmptyResponseRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    arg: str | None

    __fidl_kind__ = "struct"
    __fidl_type__ = (
        "WithAndWithoutRequestResponseWithRequestEmptyResponseRequest"
    )
    __fidl_raw_type__ = "test.protocols/WithAndWithoutRequestResponseWithRequestEmptyResponseRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithAndWithoutRequestResponseWithRequestEmptyResponseRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "arg": None,
            }
        )


@dataclass
class WithAndWithoutRequestResponseWithRequestNoResponseRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    arg: str | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithAndWithoutRequestResponseWithRequestNoResponseRequest"
    __fidl_raw_type__ = "test.protocols/WithAndWithoutRequestResponseWithRequestNoResponseRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithAndWithoutRequestResponseWithRequestNoResponseRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "arg": None,
            }
        )


@dataclass
class WithAndWithoutRequestResponseWithRequestWithResponseRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    arg: str | None

    __fidl_kind__ = "struct"
    __fidl_type__ = (
        "WithAndWithoutRequestResponseWithRequestWithResponseRequest"
    )
    __fidl_raw_type__ = "test.protocols/WithAndWithoutRequestResponseWithRequestWithResponseRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithAndWithoutRequestResponseWithRequestWithResponseRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "arg": None,
            }
        )


@dataclass
class WithAndWithoutRequestResponseWithRequestWithResponseResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    ret: str | None

    __fidl_kind__ = "struct"
    __fidl_type__ = (
        "WithAndWithoutRequestResponseWithRequestWithResponseResponse"
    )
    __fidl_raw_type__ = "test.protocols/WithAndWithoutRequestResponseWithRequestWithResponseResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithAndWithoutRequestResponseWithRequestWithResponseResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "ret": None,
            }
        )


@dataclass
class WithErrorSyntaxErrorAsEnumResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithErrorSyntaxErrorAsEnumResponse"
    __fidl_raw_type__ = "test.protocols/WithErrorSyntax_ErrorAsEnum_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithErrorSyntax_ErrorAsEnum_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class WithErrorSyntaxErrorAsPrimitiveResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithErrorSyntaxErrorAsPrimitiveResponse"
    __fidl_raw_type__ = (
        "test.protocols/WithErrorSyntax_ErrorAsPrimitive_Response"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithErrorSyntax_ErrorAsPrimitive_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class WithErrorSyntaxHandleInResultResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    h: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithErrorSyntaxHandleInResultResponse"
    __fidl_raw_type__ = "test.protocols/WithErrorSyntax_HandleInResult_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithErrorSyntax_HandleInResult_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "h": None,
            }
        )


@dataclass
class WithErrorSyntaxResponseAsStructResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    a: int | None
    b: int | None
    c: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithErrorSyntaxResponseAsStructResponse"
    __fidl_raw_type__ = (
        "test.protocols/WithErrorSyntax_ResponseAsStruct_Response"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithErrorSyntax_ResponseAsStruct_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "a": None,
                "b": None,
                "c": None,
            }
        )


@dataclass
class WithProtocolEndsClientEndsRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    in_: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithProtocolEndsClientEndsRequest"
    __fidl_raw_type__ = "test.protocols/WithProtocolEndsClientEndsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithProtocolEndsClientEndsRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "in_": None,
            }
        )


@dataclass
class WithProtocolEndsClientEndsResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    out: typing.Optional[int] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithProtocolEndsClientEndsResponse"
    __fidl_raw_type__ = "test.protocols/WithProtocolEndsClientEndsResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithProtocolEndsClientEndsResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "out": None,
            }
        )


@dataclass
class WithProtocolEndsServerEndsRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    in_: typing.Optional[int] | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithProtocolEndsServerEndsRequest"
    __fidl_raw_type__ = "test.protocols/WithProtocolEndsServerEndsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithProtocolEndsServerEndsRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "in_": None,
            }
        )


@dataclass
class WithProtocolEndsServerEndsResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    out: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithProtocolEndsServerEndsResponse"
    __fidl_raw_type__ = "test.protocols/WithProtocolEndsServerEndsResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithProtocolEndsServerEndsResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "out": None,
            }
        )


@dataclass
class WithProtocolEndsStructContainingEndsRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    in_: ProtocolEnds | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithProtocolEndsStructContainingEndsRequest"
    __fidl_raw_type__ = (
        "test.protocols/WithProtocolEndsStructContainingEndsRequest"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithProtocolEndsStructContainingEndsRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "in_": None,
            }
        )


@dataclass
class WithProtocolEndsStructContainingEndsResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    out: ProtocolEnds | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "WithProtocolEndsStructContainingEndsResponse"
    __fidl_raw_type__ = (
        "test.protocols/WithProtocolEndsStructContainingEndsResponse"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithProtocolEndsStructContainingEndsResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "out": None,
            }
        )


class TheUnion:
    _v: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "TheUnion"
    __fidl_raw_type__ = "test.protocols/TheUnion"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.v != other.v:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.v:
            variant = f"v={self.v!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        v: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if v is not None:
            self._v = v
            variants.append("v")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def v(self) -> int | None:
        return getattr(self, "_v", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.protocols", "test.protocols/TheUnion"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class WithErrorSyntaxErrorAsEnumResult:
    _response: typing.Optional[None]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "WithErrorSyntaxErrorAsEnumResult"
    __fidl_raw_type__ = "test.protocols/WithErrorSyntax_ErrorAsEnum_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[None] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> None | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithErrorSyntax_ErrorAsEnum_Result",
        )

    def unwrap(self) -> None:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            not hasattr(self, "_response") or self._response is None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Response value present when it should be None: {self._response}"

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class WithErrorSyntaxErrorAsPrimitiveResult:
    _response: typing.Optional[None]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "WithErrorSyntaxErrorAsPrimitiveResult"
    __fidl_raw_type__ = "test.protocols/WithErrorSyntax_ErrorAsPrimitive_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[None] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> None | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithErrorSyntax_ErrorAsPrimitive_Result",
        )

    def unwrap(self) -> None:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            not hasattr(self, "_response") or self._response is None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Response value present when it should be None: {self._response}"

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class WithErrorSyntaxHandleInResultResult:
    _response: typing.Optional[WithErrorSyntaxHandleInResultResponse]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "WithErrorSyntaxHandleInResultResult"
    __fidl_raw_type__ = "test.protocols/WithErrorSyntax_HandleInResult_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[WithErrorSyntaxHandleInResultResponse] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> WithErrorSyntaxHandleInResultResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithErrorSyntax_HandleInResult_Result",
        )

    def unwrap(self) -> WithErrorSyntaxHandleInResultResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class WithErrorSyntaxResponseAsStructResult:
    _response: typing.Optional[WithErrorSyntaxResponseAsStructResponse]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "WithErrorSyntaxResponseAsStructResult"
    __fidl_raw_type__ = "test.protocols/WithErrorSyntax_ResponseAsStruct_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            WithErrorSyntaxResponseAsStructResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> WithErrorSyntaxResponseAsStructResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocols",
            "test.protocols/WithErrorSyntax_ResponseAsStruct_Result",
        )

    def unwrap(self) -> WithErrorSyntaxResponseAsStructResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


ErrorEnum = enum.IntEnum(
    "ErrorEnum",
    {
        "__fidl_kind__": "enum",
        "__fidl_type__": "ErrorEnum",
        "__fidl_raw_type__": "test.protocols/ErrorEnum",
        "__strict__": True,
        "ERR_FOO": 1,
        "ERR_BAR": 2,
        "EMPTY__": 0,
        "make_default": classmethod(lambda cls: cls(0)),
    },
)


class AnotherDiscoverableProtocolServer(fidl._server.ServerBase):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class AnotherDiscoverableProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class AnotherDiscoverableProtocolEventHandler(fidl._client.EventHandlerBase):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


AnotherDiscoverableProtocolMarker = fidl._library.ProtocolMarker(
    "fake.library.FakeProtocol"
)


class ChannelProtocolServer(fidl._server.ServerBase):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class ChannelProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class ChannelProtocolEventHandler(fidl._client.EventHandlerBase):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


ChannelProtocolMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.protocols/ChannelProtocol"
)


class DiscoverableProtocolServer(fidl._server.ServerBase):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class DiscoverableProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class DiscoverableProtocolEventHandler(fidl._client.EventHandlerBase):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


DiscoverableProtocolMarker = fidl._library.ProtocolMarker(
    "test.protocols.DiscoverableProtocol"
)


class HandleRightsProtocolServer(fidl._server.ServerBase):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class HandleRightsProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class HandleRightsProtocolEventHandler(fidl._client.EventHandlerBase):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


HandleRightsProtocolMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.protocols/HandleRightsProtocol"
)


class ManyParametersServer(fidl._server.ServerBase):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class ManyParametersClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class ManyParametersEventHandler(fidl._client.EventHandlerBase):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


ManyParametersMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.protocols/ManyParameters"
)


class MethodWithUnionServer(fidl._server.ServerBase):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class MethodWithUnionClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class MethodWithUnionEventHandler(fidl._client.EventHandlerBase):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


MethodWithUnionMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.protocols/MethodWithUnion"
)


class PlatformServerServer(fidl._server.ServerBase):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class PlatformServerClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class PlatformServerEventHandler(fidl._client.EventHandlerBase):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


PlatformServerMarker = fidl._library.ProtocolMarker(
    "test.protocols.PlatformServer"
)


class WithAndWithoutRequestResponseServer(fidl._server.ServerBase):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class WithAndWithoutRequestResponseClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class WithAndWithoutRequestResponseEventHandler(fidl._client.EventHandlerBase):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


WithAndWithoutRequestResponseMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.protocols/WithAndWithoutRequestResponse"
)


class WithErrorSyntaxServer(fidl._server.ServerBase):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class WithErrorSyntaxClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class WithErrorSyntaxEventHandler(fidl._client.EventHandlerBase):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


WithErrorSyntaxMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.protocols/WithErrorSyntax"
)


class WithProtocolEndsServer(fidl._server.ServerBase):
    __fidl_kind__ = "server"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class WithProtocolEndsClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class WithProtocolEndsEventHandler(fidl._client.EventHandlerBase):
    __fidl_kind__ = "event_handler"
    library = "test.protocols"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


WithProtocolEndsMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.protocols/WithProtocolEnds"
)
