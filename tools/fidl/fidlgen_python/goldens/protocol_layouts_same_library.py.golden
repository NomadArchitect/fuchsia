# WARNING: This file is machine generated by fidlgen.

from __future__ import annotations

from dataclasses import dataclass

# TODO(https://fxbug.dev/346628306): Enable type checking here once fidl_codec has stubs
from fidl_codec import add_ir_path, encode_fidl_object  # type: ignore
import sys
import typing
import enum

import fidl

_ir_path = fidl._library.get_fidl_ir_map()["test.protocollayoutssamelibrary"]
add_ir_path(_ir_path)


@dataclass
class ComposedProtocolOneWayAnonComposedRequest:
    a: int | None

    def __init__(
        self,
        a: int | None = None,
    ) -> None:
        self.a = a

    __fidl_kind__ = "table"
    __fidl_type__ = "ComposedProtocolOneWayAnonComposedRequest"
    __fidl_raw_type__ = "test.protocollayoutssamelibrary/ComposedProtocolOneWayAnonComposedRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/ComposedProtocolOneWayAnonComposedRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class ComposedProtocolTwoWayAnonComposedResponse:
    a: int | None

    def __init__(
        self,
        a: int | None = None,
    ) -> None:
        self.a = a

    __fidl_kind__ = "table"
    __fidl_type__ = "ComposedProtocolTwoWayAnonComposedResponse"
    __fidl_raw_type__ = "test.protocollayoutssamelibrary/ComposedProtocolTwoWayAnonComposedResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/ComposedProtocolTwoWayAnonComposedResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class ComposedProtocolTwoWayAnonComposedWithErrorRequest:
    a: int | None

    def __init__(
        self,
        a: int | None = None,
    ) -> None:
        self.a = a

    __fidl_kind__ = "table"
    __fidl_type__ = "ComposedProtocolTwoWayAnonComposedWithErrorRequest"
    __fidl_raw_type__ = "test.protocollayoutssamelibrary/ComposedProtocolTwoWayAnonComposedWithErrorRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/ComposedProtocolTwoWayAnonComposedWithErrorRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class MainProtocolOneWayAnonRequest:
    a: int | None

    def __init__(
        self,
        a: int | None = None,
    ) -> None:
        self.a = a

    __fidl_kind__ = "table"
    __fidl_type__ = "MainProtocolOneWayAnonRequest"
    __fidl_raw_type__ = (
        "test.protocollayoutssamelibrary/MainProtocolOneWayAnonRequest"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/MainProtocolOneWayAnonRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class MainProtocolTwoWayAnonResponse:
    a: int | None

    def __init__(
        self,
        a: int | None = None,
    ) -> None:
        self.a = a

    __fidl_kind__ = "table"
    __fidl_type__ = "MainProtocolTwoWayAnonResponse"
    __fidl_raw_type__ = (
        "test.protocollayoutssamelibrary/MainProtocolTwoWayAnonResponse"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/MainProtocolTwoWayAnonResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class MainProtocolTwoWayAnonWithErrorRequest:
    a: int | None

    def __init__(
        self,
        a: int | None = None,
    ) -> None:
        self.a = a

    __fidl_kind__ = "table"
    __fidl_type__ = "MainProtocolTwoWayAnonWithErrorRequest"
    __fidl_raw_type__ = (
        "test.protocollayoutssamelibrary/MainProtocolTwoWayAnonWithErrorRequest"
    )

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/MainProtocolTwoWayAnonWithErrorRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class TablePayload:
    a: int | None

    def __init__(
        self,
        a: int | None = None,
    ) -> None:
        self.a = a

    __fidl_kind__ = "table"
    __fidl_type__ = "TablePayload"
    __fidl_raw_type__ = "test.protocollayoutssamelibrary/TablePayload"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/TablePayload",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


class ComposedProtocolOnAnonComposedRequest:
    _b: typing.Optional[bool]

    __fidl_kind__ = "union"
    __fidl_type__ = "ComposedProtocolOnAnonComposedRequest"
    __fidl_raw_type__ = (
        "test.protocollayoutssamelibrary/ComposedProtocolOnAnonComposedRequest"
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.b != other.b:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.b:
            variant = f"b={self.b!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        b: typing.Optional[bool] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if b is not None:
            self._b = b
            variants.append("b")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def b(self) -> bool | None:
        return getattr(self, "_b", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/ComposedProtocolOnAnonComposedRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class ComposedProtocolTwoWayAnonComposedRequest:
    _b: typing.Optional[bool]

    __fidl_kind__ = "union"
    __fidl_type__ = "ComposedProtocolTwoWayAnonComposedRequest"
    __fidl_raw_type__ = "test.protocollayoutssamelibrary/ComposedProtocolTwoWayAnonComposedRequest"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.b != other.b:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.b:
            variant = f"b={self.b!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        b: typing.Optional[bool] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if b is not None:
            self._b = b
            variants.append("b")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def b(self) -> bool | None:
        return getattr(self, "_b", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/ComposedProtocolTwoWayAnonComposedRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class ComposedProtocolTwoWayAnonComposedWithErrorResponse:
    _b: typing.Optional[bool]

    __fidl_kind__ = "union"
    __fidl_type__ = "ComposedProtocolTwoWayAnonComposedWithErrorResponse"
    __fidl_raw_type__ = "test.protocollayoutssamelibrary/ComposedProtocol_TwoWayAnonComposedWithError_Response"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.b != other.b:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.b:
            variant = f"b={self.b!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        b: typing.Optional[bool] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if b is not None:
            self._b = b
            variants.append("b")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def b(self) -> bool | None:
        return getattr(self, "_b", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/ComposedProtocol_TwoWayAnonComposedWithError_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class ComposedProtocolTwoWayAnonComposedWithErrorResult:
    _response: typing.Optional[
        ComposedProtocolTwoWayAnonComposedWithErrorResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "ComposedProtocolTwoWayAnonComposedWithErrorResult"
    __fidl_raw_type__ = "test.protocollayoutssamelibrary/ComposedProtocol_TwoWayAnonComposedWithError_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            ComposedProtocolTwoWayAnonComposedWithErrorResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> ComposedProtocolTwoWayAnonComposedWithErrorResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/ComposedProtocol_TwoWayAnonComposedWithError_Result",
        )

    def unwrap(self) -> ComposedProtocolTwoWayAnonComposedWithErrorResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class ComposedProtocolTwoWayNamedComposedWithErrorResult:
    _response: typing.Optional[UnionPayload]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "ComposedProtocolTwoWayNamedComposedWithErrorResult"
    __fidl_raw_type__ = "test.protocollayoutssamelibrary/ComposedProtocol_TwoWayNamedComposedWithError_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[UnionPayload] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> UnionPayload | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/ComposedProtocol_TwoWayNamedComposedWithError_Result",
        )

    def unwrap(self) -> UnionPayload:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class MainProtocolOnAnonRequest:
    _b: typing.Optional[bool]

    __fidl_kind__ = "union"
    __fidl_type__ = "MainProtocolOnAnonRequest"
    __fidl_raw_type__ = (
        "test.protocollayoutssamelibrary/MainProtocolOnAnonRequest"
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.b != other.b:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.b:
            variant = f"b={self.b!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        b: typing.Optional[bool] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if b is not None:
            self._b = b
            variants.append("b")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def b(self) -> bool | None:
        return getattr(self, "_b", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/MainProtocolOnAnonRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class MainProtocolTwoWayAnonRequest:
    _b: typing.Optional[bool]

    __fidl_kind__ = "union"
    __fidl_type__ = "MainProtocolTwoWayAnonRequest"
    __fidl_raw_type__ = (
        "test.protocollayoutssamelibrary/MainProtocolTwoWayAnonRequest"
    )

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.b != other.b:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.b:
            variant = f"b={self.b!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        b: typing.Optional[bool] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if b is not None:
            self._b = b
            variants.append("b")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def b(self) -> bool | None:
        return getattr(self, "_b", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/MainProtocolTwoWayAnonRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class MainProtocolTwoWayAnonWithErrorResponse:
    _b: typing.Optional[bool]

    __fidl_kind__ = "union"
    __fidl_type__ = "MainProtocolTwoWayAnonWithErrorResponse"
    __fidl_raw_type__ = "test.protocollayoutssamelibrary/MainProtocol_TwoWayAnonWithError_Response"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.b != other.b:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.b:
            variant = f"b={self.b!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        b: typing.Optional[bool] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if b is not None:
            self._b = b
            variants.append("b")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def b(self) -> bool | None:
        return getattr(self, "_b", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/MainProtocol_TwoWayAnonWithError_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class MainProtocolTwoWayAnonWithErrorResult:
    _response: typing.Optional[MainProtocolTwoWayAnonWithErrorResponse]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "MainProtocolTwoWayAnonWithErrorResult"
    __fidl_raw_type__ = "test.protocollayoutssamelibrary/MainProtocol_TwoWayAnonWithError_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            MainProtocolTwoWayAnonWithErrorResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> MainProtocolTwoWayAnonWithErrorResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/MainProtocol_TwoWayAnonWithError_Result",
        )

    def unwrap(self) -> MainProtocolTwoWayAnonWithErrorResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class MainProtocolTwoWayLocalWithErrorResult:
    _response: typing.Optional[UnionPayload]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "MainProtocolTwoWayLocalWithErrorResult"
    __fidl_raw_type__ = "test.protocollayoutssamelibrary/MainProtocol_TwoWayLocalWithError_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[UnionPayload] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> UnionPayload | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/MainProtocol_TwoWayLocalWithError_Result",
        )

    def unwrap(self) -> UnionPayload:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnionPayload:
    _b: typing.Optional[bool]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnionPayload"
    __fidl_raw_type__ = "test.protocollayoutssamelibrary/UnionPayload"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.b != other.b:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.b:
            variant = f"b={self.b!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        b: typing.Optional[bool] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if b is not None:
            self._b = b
            variants.append("b")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def b(self) -> bool | None:
        return getattr(self, "_b", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.protocollayoutssamelibrary",
            "test.protocollayoutssamelibrary/UnionPayload",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class ComposedProtocolServer(fidl._server.ServerBase):
    __fidl_kind__ = "server"
    library = "test.protocollayoutssamelibrary"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class ComposedProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocollayoutssamelibrary"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class ComposedProtocolEventHandler(fidl._client.EventHandlerBase):
    __fidl_kind__ = "event_handler"
    library = "test.protocollayoutssamelibrary"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


ComposedProtocolMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.protocollayoutssamelibrary/ComposedProtocol"
)


class MainProtocolServer(fidl._server.ServerBase):
    __fidl_kind__ = "server"
    library = "test.protocollayoutssamelibrary"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class MainProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.protocollayoutssamelibrary"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class MainProtocolEventHandler(fidl._client.EventHandlerBase):
    __fidl_kind__ = "event_handler"
    library = "test.protocollayoutssamelibrary"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


MainProtocolMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.protocollayoutssamelibrary/MainProtocol"
)
