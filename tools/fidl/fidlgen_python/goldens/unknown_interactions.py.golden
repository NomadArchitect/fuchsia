# WARNING: This file is machine generated by fidlgen.

from __future__ import annotations

from dataclasses import dataclass

# TODO(https://fxbug.dev/346628306): Enable type checking here once fidl_codec has stubs
from fidl_codec import add_ir_path, encode_fidl_object  # type: ignore
import sys
import typing
import enum

import fidl

_ir_path = fidl._library.get_fidl_ir_map()["test.unknowninteractions"]
add_ir_path(_ir_path)


@dataclass
class UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolFlexibleEventFieldsRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsAjarProtocolStrictEventFieldsRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictEventFieldsRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictEventFieldsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictEventFieldsRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayFieldsResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsAjarProtocolStrictTwoWayErrResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictTwoWayErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = (
        "UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsClosedProtocolStrictEventFieldsRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsClosedProtocolStrictEventFieldsRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictEventFieldsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictEventFieldsRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = (
        "UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayFieldsResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsClosedProtocolStrictTwoWayErrResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsClosedProtocolStrictTwoWayErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = (
        "UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsProtocolFlexibleEventFieldsRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleEventFieldsRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolFlexibleEventFieldsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolFlexibleEventFieldsRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsProtocolStrictEventFieldsRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolStrictEventFieldsRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolStrictEventFieldsRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolStrictEventFieldsRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsProtocolStrictTwoWayFieldsResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayFieldsResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayFieldsResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayFieldsResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsProtocolFlexibleTwoWayErrResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFields_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFields_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsProtocolFlexibleTwoWayResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWay_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWay_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class UnknownInteractionsProtocolStrictTwoWayErrResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    some_field: int | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "some_field": None,
            }
        )


@dataclass
class UnknownInteractionsAjarProtocolFlexibleEventTableRequest:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsAjarProtocolFlexibleEventTableRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolFlexibleEventTableRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolFlexibleEventTableRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsAjarProtocolStrictEventTableRequest:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictEventTableRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictEventTableRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictEventTableRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsAjarProtocolStrictTwoWayTableResponse:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictTwoWayTableResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayTableResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayTableResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = (
        "UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsClosedProtocolStrictEventTableRequest:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsClosedProtocolStrictEventTableRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictEventTableRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictEventTableRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsClosedProtocolStrictTwoWayTableResponse:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsClosedProtocolStrictTwoWayTableResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayTableResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayTableResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = (
        "UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsProtocolFlexibleEventTableRequest:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleEventTableRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolFlexibleEventTableRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolFlexibleEventTableRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsProtocolStrictEventTableRequest:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsProtocolStrictEventTableRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolStrictEventTableRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolStrictEventTableRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsProtocolStrictTwoWayTableResponse:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayTableResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayTableResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayTableResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsProtocolFlexibleTwoWayTableResponse:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayTableResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTable_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTable_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


@dataclass
class UnknownInteractionsProtocolStrictTwoWayTableErrResponse:
    some_field: int | None

    def __init__(
        self,
        some_field: int | None = None,
    ) -> None:
        self.some_field = some_field

    __fidl_kind__ = "table"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayTableErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayTableErr_Response"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayTableErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls()


class UnknownInteractionsAjarProtocolFlexibleEventUnionRequest:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsAjarProtocolFlexibleEventUnionRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolFlexibleEventUnionRequest"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolFlexibleEventUnionRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsAjarProtocolStrictEventUnionRequest:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictEventUnionRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictEventUnionRequest"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictEventUnionRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocolStrictTwoWayUnionResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsAjarProtocolStrictTwoWayErrResult:
    _response: typing.Optional[None]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictTwoWayErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[None] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> None | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayErr_Result",
        )

    def unwrap(self) -> None:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            not hasattr(self, "_response") or self._response is None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Response value present when it should be None: {self._response}"

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult:
    _response: typing.Optional[
        UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayFieldsErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsAjarProtocolStrictTwoWayFieldsErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult:
    _response: typing.Optional[
        UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictTwoWayTableErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayTableErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsAjarProtocolStrictTwoWayTableErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = (
        "UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult:
    _response: typing.Optional[
        UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsAjarProtocol_StrictTwoWayUnionErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsAjarProtocolStrictTwoWayUnionErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsClosedProtocolStrictEventUnionRequest:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsClosedProtocolStrictEventUnionRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictEventUnionRequest"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictEventUnionRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocolStrictTwoWayUnionResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsClosedProtocolStrictTwoWayErrResult:
    _response: typing.Optional[None]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsClosedProtocolStrictTwoWayErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[None] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> None | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayErr_Result",
        )

    def unwrap(self) -> None:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            not hasattr(self, "_response") or self._response is None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Response value present when it should be None: {self._response}"

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult:
    _response: typing.Optional[
        UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = (
        "UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResult"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayFieldsErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsClosedProtocolStrictTwoWayFieldsErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult:
    _response: typing.Optional[
        UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = (
        "UnknownInteractionsClosedProtocolStrictTwoWayTableErrResult"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayTableErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsClosedProtocolStrictTwoWayTableErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = (
        "UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult:
    _response: typing.Optional[
        UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = (
        "UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResult"
    )
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsClosedProtocol_StrictTwoWayUnionErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsClosedProtocolStrictTwoWayUnionErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleEventUnionRequest:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleEventUnionRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolFlexibleEventUnionRequest"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolFlexibleEventUnionRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolStrictEventUnionRequest:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolStrictEventUnionRequest"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolStrictEventUnionRequest"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolStrictEventUnionRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolStrictTwoWayUnionResponse:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayUnionResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayUnionResponse"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocolStrictTwoWayUnionResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayErrResult:
    _response: typing.Optional[None]
    _err: typing.Optional[int]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayErr_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[None] = None,
        err: typing.Optional[int] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> None | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayErr_Result",
        )

    def unwrap(self) -> None:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            not hasattr(self, "_response") or self._response is None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Response value present when it should be None: {self._response}"

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
    ]
    _err: typing.Optional[int]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFieldsErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayFieldsErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayFieldsResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
    ]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayFieldsResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFields_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse
        ] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse | None:
        return getattr(self, "_response", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayFields_Result",
        )

    def unwrap(self) -> UnknownInteractionsProtocolFlexibleTwoWayFieldsResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayTableErrResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
    ]
    _err: typing.Optional[int]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayTableErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTableErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayTableErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayTableResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolFlexibleTwoWayTableResponse
    ]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayTableResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTable_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolFlexibleTwoWayTableResponse
        ] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayTableResponse | None:
        return getattr(self, "_response", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayTable_Result",
        )

    def unwrap(self) -> UnknownInteractionsProtocolFlexibleTwoWayTableResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
    ]
    _err: typing.Optional[int]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayUnionErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnionErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayUnionErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayUnionResponse:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayUnionResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnion_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayUnionResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
    ]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayUnionResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolFlexibleTwoWayUnionResponse
        ] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolFlexibleTwoWayUnionResponse | None:
        return getattr(self, "_response", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWayUnion_Result",
        )

    def unwrap(self) -> UnknownInteractionsProtocolFlexibleTwoWayUnionResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolFlexibleTwoWayResult:
    _response: typing.Optional[None]
    _framework_err: typing.Optional[fidl.FrameworkError]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolFlexibleTwoWayResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWay_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.framework_err != other.framework_err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.framework_err:
            variant = f"framework_err={self.framework_err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[None] = None,
        framework_err: typing.Optional[fidl.FrameworkError] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if framework_err is not None:
            self._framework_err = framework_err
            variants.append("framework_err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> None | None:
        return getattr(self, "_response", None)

    @property
    def framework_err(self) -> fidl.FrameworkError | None:
        return getattr(self, "_framework_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_FlexibleTwoWay_Result",
        )

    def unwrap(self) -> None:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            not hasattr(self, "_response") or self._response is None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Response value present when it should be None: {self._response}"

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolStrictTwoWayErrResult:
    _response: typing.Optional[None]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayErr_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[None] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(self) -> None | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayErr_Result",
        )

    def unwrap(self) -> None:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            not hasattr(self, "_response") or self._response is None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Response value present when it should be None: {self._response}"

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolStrictTwoWayFieldsErrResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayFieldsErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayFieldsErr_Result",
        )

    def unwrap(
        self,
    ) -> UnknownInteractionsProtocolStrictTwoWayFieldsErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolStrictTwoWayTableErrResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolStrictTwoWayTableErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayTableErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayTableErr_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolStrictTwoWayTableErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolStrictTwoWayTableErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayTableErr_Result",
        )

    def unwrap(self) -> UnknownInteractionsProtocolStrictTwoWayTableErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolStrictTwoWayUnionErrResponse:
    _some_field: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayUnionErrResponse"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.some_field != other.some_field:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.some_field:
            variant = f"some_field={self.some_field!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        some_field: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if some_field is not None:
            self._some_field = some_field
            variants.append("some_field")
            number_of_variants += 1
        if number_of_variants != 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def some_field(self) -> int | None:
        return getattr(self, "_some_field", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayUnionErr_Response",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsProtocolStrictTwoWayUnionErrResult:
    _response: typing.Optional[
        UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
    ]
    _err: typing.Optional[int]

    __fidl_kind__ = "union"
    __fidl_type__ = "UnknownInteractionsProtocolStrictTwoWayUnionErrResult"
    __fidl_raw_type__ = "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result"

    def __eq__(self, other: object) -> bool:
        if not isinstance(other, type(self)):
            return False
        if self.response != other.response:
            return False
        if self.err != other.err:
            return False
        return True

    def __repr__(self) -> str:
        """Returns the union repr in the format <'foo.bar.baz/FooUnion' object({value})>

        If {value} is not set, will write None."""
        variant = ""
        if self.response:
            variant = f"response={self.response!r}"
        if self.err:
            variant = f"err={self.err!r}"
        return f"<'{self.__fidl_type__}' object({variant})>"

    def __init__(
        self,
        response: typing.Optional[
            UnknownInteractionsProtocolStrictTwoWayUnionErrResponse
        ] = None,
        err: typing.Optional[int] = None,
        _empty: typing.Optional[tuple[()]] = None,
    ):
        object.__init__(self)
        if _empty is not None:
            return

        number_of_variants = 0
        variants = []

        if response is not None:
            self._response = response
            variants.append("response")
            number_of_variants += 1
        if err is not None:
            self._err = err
            variants.append("err")
            number_of_variants += 1
        if number_of_variants > 1:
            raise TypeError(
                f"Exactly one variant must be specified for {self.__fidl_raw_type__}: {variants}"
            )

    @property
    def response(
        self,
    ) -> UnknownInteractionsProtocolStrictTwoWayUnionErrResponse | None:
        return getattr(self, "_response", None)

    @property
    def err(self) -> int | None:
        return getattr(self, "_err", None)

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.unknowninteractions",
            "test.unknowninteractions/UnknownInteractionsProtocol_StrictTwoWayUnionErr_Result",
        )

    def unwrap(self) -> UnknownInteractionsProtocolStrictTwoWayUnionErrResponse:
        """Returns the response if result does not contain an error. Otherwise, raises an exception."""
        try:
            if (
                hasattr(self, "_framework_err")
                and self._framework_err is not None
            ):
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} framework error {self._framework_err}"
                )
        except AttributeError:
            pass
        try:
            if hasattr(self, "_err") and self._err is not None:
                raise RuntimeError(
                    f"{self.__fidl_raw_type__} error {self._err}"
                )
        except AttributeError:
            pass

        assert (
            self._response is not None
        ), f"Failed to unwrap {self.__fidl_raw_type__}. Result does not contain an error or response."
        return self._response

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(_empty=())


class UnknownInteractionsAjarProtocolServer(fidl._server.ServerBase):
    __fidl_kind__ = "server"
    library = "test.unknowninteractions"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class UnknownInteractionsAjarProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.unknowninteractions"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class UnknownInteractionsAjarProtocolEventHandler(
    fidl._client.EventHandlerBase
):
    __fidl_kind__ = "event_handler"
    library = "test.unknowninteractions"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


UnknownInteractionsAjarProtocolMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.unknowninteractions/UnknownInteractionsAjarProtocol"
)


class UnknownInteractionsClosedProtocolServer(fidl._server.ServerBase):
    __fidl_kind__ = "server"
    library = "test.unknowninteractions"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class UnknownInteractionsClosedProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.unknowninteractions"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class UnknownInteractionsClosedProtocolEventHandler(
    fidl._client.EventHandlerBase
):
    __fidl_kind__ = "event_handler"
    library = "test.unknowninteractions"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


UnknownInteractionsClosedProtocolMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.unknowninteractions/UnknownInteractionsClosedProtocol"
)


class UnknownInteractionsProtocolServer(fidl._server.ServerBase):
    __fidl_kind__ = "server"
    library = "test.unknowninteractions"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class UnknownInteractionsProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.unknowninteractions"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class UnknownInteractionsProtocolEventHandler(fidl._client.EventHandlerBase):
    __fidl_kind__ = "event_handler"
    library = "test.unknowninteractions"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


UnknownInteractionsProtocolMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.unknowninteractions/UnknownInteractionsProtocol"
)
