# WARNING: This file is machine generated by fidlgen.

from __future__ import annotations

from dataclasses import dataclass

# TODO(https://fxbug.dev/346628306): Enable type checking here once fidl_codec has stubs
from fidl_codec import add_ir_path, encode_fidl_object  # type: ignore
import sys
import typing
import enum

import fidl

_ir_path = fidl._library.get_fidl_ir_map()["test.emptystruct"]
add_ir_path(_ir_path)


@dataclass
class Empty:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.

    __fidl_kind__ = "struct"
    __fidl_type__ = "Empty"
    __fidl_raw_type__ = "test.emptystruct/Empty"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self, "test.emptystruct", "test.emptystruct/Empty"
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(**{})


@dataclass
class EmptyProtocolReceiveRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    e: Empty | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "EmptyProtocolReceiveRequest"
    __fidl_raw_type__ = "test.emptystruct/EmptyProtocolReceiveRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.emptystruct",
            "test.emptystruct/EmptyProtocolReceiveRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "e": None,
            }
        )


@dataclass
class EmptyProtocolSendAndReceiveRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    e: Empty | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "EmptyProtocolSendAndReceiveRequest"
    __fidl_raw_type__ = "test.emptystruct/EmptyProtocolSendAndReceiveRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.emptystruct",
            "test.emptystruct/EmptyProtocolSendAndReceiveRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "e": None,
            }
        )


@dataclass
class EmptyProtocolSendAndReceiveResponse:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    e: Empty | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "EmptyProtocolSendAndReceiveResponse"
    __fidl_raw_type__ = "test.emptystruct/EmptyProtocolSendAndReceiveResponse"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.emptystruct",
            "test.emptystruct/EmptyProtocolSendAndReceiveResponse",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "e": None,
            }
        )


@dataclass
class EmptyProtocolSendRequest:
    # TODO(https://fxbug.dev/394421154): The None variant of each type is a consequence
    # of needing to support creation of a "default object" before decoding.
    e: Empty | None

    __fidl_kind__ = "struct"
    __fidl_type__ = "EmptyProtocolSendRequest"
    __fidl_raw_type__ = "test.emptystruct/EmptyProtocolSendRequest"

    # TODO(https://fxbug.dev/394421154): We should probably remove this method when we
    # start making breaking changes.
    def __getitem__(self, item: str):  # type: ignore
        if not isinstance(item, str):
            raise TypeError("Subscripted item must be a string")
        return getattr(self, item)

    # TODO(https://fxbug.dev/394421154): We should probably return a more readable type.
    def encode(self) -> tuple[bytes, list[tuple[int, int, int, int, int]]]:
        return encode_fidl_object(
            self,
            "test.emptystruct",
            "test.emptystruct/EmptyProtocolSendRequest",
        )

    @classmethod
    def make_default(cls) -> typing.Self:
        return cls(
            **{
                "e": None,
            }
        )


class EmptyProtocolServer(fidl._server.ServerBase):
    __fidl_kind__ = "server"
    library = "test.emptystruct"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class EmptyProtocolClient(fidl._client.FidlClient):
    __fidl_kind__ = "client"
    library = "test.emptystruct"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


class EmptyProtocolEventHandler(fidl._client.EventHandlerBase):
    __fidl_kind__ = "event_handler"
    library = "test.emptystruct"
    method_map: typing.Dict[int, typing.Callable[..., typing.Any]] = {}


EmptyProtocolMarker = fidl._library.ProtocolMarker(
    "(nondiscoverable) test.emptystruct/EmptyProtocol"
)
